const crypto = require('crypto')
const { stringToBase64 } = require('utils')
const { HttpClient, retrieveLerexLiveSecret, KYCuploader } = require('aws-layer')

const LEREX_SECRET = process.env.virtCardSecretName
const OPEX_SECRET = process.env.opexSecretName
const USER = process.env.lerexUser
const PASS = process.env.lerexPass
const MODE = process.env.mode
const OPEX_ACCOUNT = process.env.opexAccountID

class LerexClient {
  constructor (props) {
    this.domain = 'https://sandbox.lerextech.com/api/rest'
    const { testingMode } = props
    if (testingMode) {
      const user = USER; const password = PASS
      this.headers = {
        Authorization: 'Basic ' + stringToBase64(`${user}:${password}`),
        'Content-Type': 'application/json'
      }
    } else {
      const { key, secret } = props
      this.domain = 'https://api.lerextech.com/api/rest'
      this.headers = {
        'Content-Type': 'application/json',
        ...this.authHeaders(key, secret)
      }
    }
  }

  static async builder () {
    if (MODE === 'test') {
      return LerexClient.test()
    } else if (MODE === 'prod') {
      const { key, secret } = await retrieveLerexLiveSecret(LEREX_SECRET)
      return new LerexClient({ key, secret })
    }
  }

  static async opex () {
    const { key, secret } = await retrieveLerexLiveSecret(OPEX_SECRET)
    return new LerexClient({ key, secret })
  }

  static test () {
    return new LerexClient({
      testingMode: true
    })
  }

  authHeaders (key, secret) {
    const nonce = Date.now()
    const timestamp = Math.round(nonce / 1000)
    const signatureString = `LRX-ENC.V.1.0:${nonce}:${timestamp}:${key}`
    let encodedSignature = crypto
      .createHmac('sha1', secret)
      .update(signatureString)
      .digest('base64')
    encodedSignature = encodeURIComponent(encodedSignature)
    let convertedSignature = ''
    for (let i = 0; i < encodedSignature.length - 2; i++) {
      convertedSignature += encodedSignature[i]
      if (encodedSignature[i] === '%') {
        convertedSignature += encodedSignature[i + 1].toLowerCase()
        convertedSignature += encodedSignature[i + 2].toLowerCase()
        i += 2
      }
    }
    return {
      'x-msg-timestamp': timestamp.toString(),
      'x-msg-nonce': nonce.toString(),
      Authorization: `Signature apiKey=${key}, signature=${convertedSignature}`
    }
  }

  async getOrganisationDetails () {
    const out = await HttpClient.request(
      'GET',
      this.domain + '/organisation/details',
      {},
      this.headers
    )
    return out
  }

  async postNewActiveUser (
    firstName,
    lastName,
    email,
    mobileNumber,
    dateOfBirth,
    houseNameNumber,
    street,
    address2,
    city,
    postCode,
    sourceOfFunds = 4,
    countryId = 2,
    emailConfirmed = true) {
    const payload = {
      firstName: firstName,
      lastName: lastName,
      email: email,
      sourceOfFunds: sourceOfFunds,
      countryId: countryId,
      emailConfirmed: 1,
      mobileNumber,
      dateOfBirth,
      houseNameNumber,
      street,
      // address2,
      city,
      postCode,
      // accountBlocked: false,
      // isDeleted: false
      mobileConfirmed: 1,
      mobileNumberConfirmed: 1
    }
    const res = await HttpClient.request(
      'post',
      this.domain + '/users',
      payload,
      this.headers
    )
    return {
      id: res.id
    }
  }

  async uploadKYCDocs (lerexID, fileLink) {
    const { headers } = this
    delete headers['Content-Type']
    await KYCuploader(
      fileLink,
      `${this.domain}/users/kyc/upload/${lerexID}`,
      headers
    )
  }

  async requestKYC (lerexID) {
    const { headers } = this
    const res = await HttpClient.request(
      'get',
      `${this.domain}/users/request-kyc-check?userId=${lerexID}`,
      {},
      headers
    )
    return res
  }

  async orderNewCard (lerexID) {
    const payload = {
      userId: lerexID,
      isVirtual: true
    }
    const res = await HttpClient.request(
      'POST',
      this.domain + '/cards/order-card',
      payload,
      this.headers
    )
    return res
  }

  async activateCard (lerexID, cardID) {
    const res = await HttpClient.request(
      'POST',
      this.domain + '/cards/activate-card/' + cardID + '/' + lerexID,
      {},
      this.headers
    )
    return res.cardStatus
  }

  async loadCard (lerexID, amount = 200) {
    const payload = {
      loads: [{
        currencyId: 1,
        amount: amount,
        userId: lerexID,
        memo: 'PollenPay BNPL'
      }],
      sendEmail: false
    }
    const res = await HttpClient.request(
      'POST',
      this.domain + '/wallet/load',
      payload,
      this.headers,
      'statusCode'
    )
  }

  async unloadCard (lerexID) {
    const res = await HttpClient.request(
      'POST',
      `${this.domain}/wallet/unload/${lerexID}`,
      {},
      this.headers,
      'statusCode'
    )
  }

  async getUser (lerexID) {
    const res = await HttpClient.request(
      'GET',
      `${this.domain}/users/${lerexID}`,
      {},
      this.headers
    )
    return res
  }

  async updateKYCStatus (lerexID, status) {
    let KYCStatus = 0
    if (status) {
      KYCStatus = 1
    }
    const res = await HttpClient.request(
      'GET',
      `${this.domain}/users/update-kyc-status?userId=${lerexID}&KYCStatus=${KYCStatus}`, {},
      this.headers,
      'statusCode'
    )
    if (res === 200) {
      return true
    } else {
      return false
    }
  }

  async getOrgAccount (accountID) {
    const res = await HttpClient.request(
      'GET',
      `${this.domain}/organisation/account-balance/${accountID}`,
      {},
      this.headers
    )
    return res
  }

  async payout (fromBankAccountID, poundAmount, beneficiaryName, accountNumber, sortCode, reference, currencyID = 1) {
    const payload = {
      fromBankAccountID,
      amount: poundAmount,
      beneficiaryName,
      accountNumber,
      sortCode,
      reference,
      currencyId: currencyID
    }
    const res = await HttpClient.request(
      'POST',
      this.domain + '/organisation/make-payment',
      payload,
      this.headers,
      'statusCode'
    )
    if (Math.floor(res / 100) === 2) {
      return true
    } else {
      return false
    }
  }

  async retrieveVirtualCard (lerexID, cardID) {
    const { cardFrameUrl } = await HttpClient.request(
      'GET',
      `${this.domain}/cards/virtual?userId=${lerexID}&cardId=${cardID}`,
      {},
      this.headers
    )

    let body =  await HttpClient.request(
      'GET',
      cardFrameUrl,
      {},
      {},
      'html'
    )
    body = body.toString().replace(/\\n/gm, '')
    body = body.replace(/\\t/gm, '')
    body = body.replace(/  /gm, '')
    body = body.replace(/'/gm, '')
    body = body.slice(1)

    return body
  }

  static cardAuthMethods = {
    0: 'Default',
    1: 'AppAuthentication',
    2: 'AppOTPAuthentication',
    3: 'AppOTPStaticPassAuthentication'
  }

  async setCardAuthMethods (cardID, lerexID, method=2) {
    const res = await HttpClient.request(
      'POST',
      `${this.domain}/cards/authmethod/${cardID}/${lerexID}/${LerexClient.cardAuthMethods[method]}`,
      {},
      this.headers,
      'statusCode'
    )
    console.log(`Setting card auth methods; response: ${res}`)
  }

  async getCardsByUser (lerexID) {
    const res = await HttpClient.request(
      'GET',
      `${this.domain}/cards?userId=${lerexID}`,
      {},
      this.headers
    )
    return res
  }

  async getCard (cardID) {
    const res = await HttpClient.request(
      'GET',
      `${this.domain}/cards/${cardID}`,
      {},
      this.headers
    )
    return res
  }
}

const newLerexAccount = async (userDetails, userStatus, userName) => {
  const { name, email, dob, address } = userDetails
  const { street_number, locality, route, administrative_division, postal_code } = address
  let { givenName, surname } = name
  if (!surname) { surname = givenName }
  if (givenName.length > 50) { givenName = givenName.slice(0, 50)}
  if (surname.length > 50) { surname = surname.slice(0, 50)}

  let lerex = await LerexClient.builder()
  const user = await lerex.postNewActiveUser(
    givenName,
    surname,
    email,
    userName,
    new Date(dob).toISOString(),
    street_number,
    route,
    '',
    locality,
    postal_code
  )
  const { id: lerexID } = user
  return lerexID
}

const submitToKYC = async (lerexID, userStatus) => {
  // if (MODE === 'prod') {
    const { idFileLink, addressFileLink } = userStatus
    lerex = await LerexClient.builder()
    await lerex.uploadKYCDocs(lerexID, idFileLink)
    lerex = await LerexClient.builder()
    await lerex.uploadKYCDocs(lerexID, addressFileLink)
    const res = await lerex.requestKYC(lerexID)
    console.log(res)
  // } else {
  //   lerex = await LerexClient.builder()
  //   await lerex.updateKYCStatus(lerexID, 1)
  // }
}

const generateNewCard = async (lerexID) => {
  let lerex
  // check if user has existing cards
  lerex = await LerexClient.builder()
  const cardList = await lerex.getCardsByUser(lerexID)
  if (cardList.length) {

  }

  // order new card and check for errors
  lerex = await LerexClient.builder()
  const { nameOnCard, endMonth, endYear, id: cardID, message: error } = await lerex.orderNewCard(lerexID)
  if (error !== null && error instanceof String) {
    if (!!error && (error.includes('Error') || error.includes('support'))) {
        throw new Error(error)
    }
  }

  // change the card's auth method to OTP -- this disables static password auth which is the default
  lerex = await LerexClient.builder()
  await lerex.setCardAuthMethods(cardID, lerexID)

  // retrive the card number and cvc via card frame (to be extracted by html parsing)
  lerex = await LerexClient.builder()
  const cardFrame = await lerex.retrieveVirtualCard(lerexID, cardID)
  return {
    card:
      {
        nameOnCard,
        cardNumber: null,
        endMonth: Number(endMonth),
        endYear: Number(endYear),
        cvc: null,
        cardID
      },
    cardFrame
  }
}

const makePayment = async (poundAmount, billingDetails, reference) => {
  const { sortCode, accountNumber, beneficiary } = billingDetails
  lerex = await LerexClient.opex()
  const payment = await lerex.payout(
    OPEX_ACCOUNT,
    poundAmount,
    beneficiary,
    accountNumber,
    sortCode,
    `PP ${reference}`
  )
  return payment
}

const loadUser = async (lerexID, amount) => {
  const lerex = await LerexClient.builder()
  await lerex.loadCard(lerexID, amount)
}

const unloadUser = async (lerexID) => {
  let lerex = await LerexClient.builder()
  await lerex.unloadCard(lerexID)

  // const { wallets } = await lerex.getUser(lerexID)
  // console.log(walllets)
  // for (const item of wallets) {
  //   if (item.currencyId === 1 && item.amountAvailable > 0) {
  //     lerex = await LerexClient.builder()
  //     await lerex.unloadCard(lerexID)
  //     break
  //   }
  // }
}

const discoverCards = async (lerexID) => {
  let lerex
  lerex = await LerexClient.builder()
  const cards = await lerex.getCardsByUser(lerexID)
  if (cards.length) {
    const { id: cardID, nameOnCard, endMonth, endYear } = cards[0]
    lerex = await LerexClient.builder()
    const cardFrame = await lerex.retrieveVirtualCard(lerexID, cardID)
    await lerex.setCardAuthMethods(cardID, lerexID)
    return {
      hasCards: true,
      cardData: {
        card:
        {
          nameOnCard,
          cardNumber: null,
          endMonth: Number(endMonth),
          endYear: Number(endYear),
          cvc: null,
          cardID
        },
      cardFrame
      }
    }
  }
  return { hasCards: false }
}

module.exports = {
  LerexClient,
  newLerexAccount,
  makePayment,
  generateNewCard,
  submitToKYC,
  loadUser,
  unloadUser,
  discoverCards
}
