const { GenericError } = require('messages')

class CustomerClientResponse {
  constructor (defaultErrorCode = 84, defaultStatusCode = 200, defaultErrorDisplay = 'errorPage', origin = 'http://localhost:3000') {
    this.defaultErrorCode = defaultErrorCode
    this.defaultErrorDisplay = defaultErrorDisplay
    this.defaultStatusCode = defaultStatusCode
    this.origin = origin
  }

  respond (err, res = null, statusCode = this.defaultStatusCode, origin = this.origin, errorDisplay = this.defaultErrorDisplay, errorCode = this.defaultErrorCode) {
    const headers = {
      'Access-Control-Allow-Origin': origin,
      'Access-Control-Allow-Methods': 'POST, PUT, GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type,X-Requested-With,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,User,AccessToken',
      'Access-Control-Allow-Credentials': 'False',
    };
    if (err) {
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
          error: true,
          message: err,
          errorDisplay,
          errorCode
        })
      }
    } else {
      if ( Math.floor(statusCode / 100) === 5 ) { logAlert(err.message) }
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
          error: false,
          body: res
        })
      }
    }
  }

  handleError (err, origin) {
    console.log(err)
    if (err instanceof PollenError) {
      return this.respond(err.message, null, err.statusCode, origin, err.errorDisplay, err.errorCode)
    }
    const genericError = GenericError.withErrorMessage(err)
    return this.respond(genericError.message, null, genericError.statusCode, origin, genericError.errorDisplay)
  }
}
exports.CustomerClientResponse = CustomerClientResponse

class PollenError extends Error {
  constructor (messageObject, ...args) {
    const { message, errorCode, statusCode, errorDisplay } = messageObject
    super(message, ...args);
    Object.assign(this, { errorCode, statusCode, errorDisplay })
  }
}
exports.PollenError = PollenError

exports.getOrigin = (eventObject) => {
  if (!!eventObject.headers && !!eventObject.headers.origin) {
    return eventObject.headers.origin
  } else {
    return '*'
  }
}

exports.authoriserResponse = (user, effect = 'Deny', resource = '*') => {
  return {
    principalId: String(user).replace(/^\+/,""),
    policyDocument: {
      Version: '2012-10-17',
      Statement: [{
        Action: 'execute-api:Invoke',
        Effect: effect,
        Resource: resource
      }]
    }
  }

}

exports.getPrincipalFromProxyEvent = (event) => {
  return event.requestContext.authorizer.principalId
}

exports.stringToBase64 = (utf8) => {
  return Buffer
    .from(utf8)
    .toString('base64')
}

class Base36 {
  static get map () {
    return '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  }

  static encode (base10Number) {
    const { map } = this
    const out = []

    if (typeof base10Number === 'string') {
      base10Number = parseInt(base10Number, 10)
    }

    if (typeof base10Number !== 'number') {
      throw new PollenError({
        message: 'Trying to parse a non-number.',
        errorCode: 84,
        statusCode: 400,
        errorDisplay: 'modal'
      })
    }
    if (base10Number < 0) {
      throw new PollenError({
        message: 'Trying to parse a non-positive number.',
        errorCode: 84,
        statusCode: 400,
        errorDisplay: 'modal'
      })
    }

    while (base10Number > 0) {
      out.push(map[base10Number % 36])
      base10Number = Math.floor(base10Number / 36)
    }
    return out.reverse().join('')
  }

  static encodeWithSeparators (base10Number) {
    const base36Number = this.encode(base10Number)
    const out = []
    let index = 0
    for (const char of base36Number) {
      out.push(char)
      index++
      if (index % 3 === 0) {
        out.push('-')
      }
    }
    if (out[out.length - 1] === '-') {
      out.pop()
    }
    return out.join('')
  }
}
exports.Base36 = Base36

// naviagetes the object tree and deletes the specified key on each level
const purgeKeys = (object, target) => {
  if (target in object) {
    delete object[target]
  }
  for (const key of Object.keys(object)) {
    if (typeof object[key] === 'object' && object[key] != null) {
      object[key] = purgeKeys(object[key], target)
    } else if (typeof object[key] === 'array' && object[key].length > 0) {
      for (const item of object[key]) {
        item = purgeKeys(item, target)
      }
    }
  }
  return object
}
exports.purgeKeys = purgeKeys

exports.paginate = (array, page = 0, perPage = 10, notation = 'camelcase') => {
  const pageCount = Math.floor(array.length / perPage) + 1
  const start = page * perPage
  const end = start + perPage
  const data =  array.slice(start, end)
  if (notation === 'snakecase') {
    return {
      data,
      meta: {
        page,
        per_page: perPage,
        page_count: pageCount
      }
    }
  } else {
    return {
      data,
      meta: {
        page,
        perPage,
        pageCount
      }
    }
  }
}

exports.timestampToHuman = (timestampSeconds) => {
  const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
  return `${days[new Date(timestampSeconds * 1000).getDay()]} ${new Date(timestampSeconds * 1000).getDate()} ${months[new Date(timestampSeconds * 1000).getMonth()]} ${new Date(timestampSeconds * 1000).getFullYear()}`
}
