
const crypto = require('crypto');

// const mysql_client = require("pp-mysql/client");
// const {
//     Q, q,
//     $exe,
//     $tbl,
//     $row,
//     $one,
// } = mysql_client.shorthands();

// default value is guaranteed to be random (tm)
const TOKEN_KEY = Buffer.alloc(16, 0);
Buffer.from(process.env.stageAccessKey || "185792249625573810c5f66bd38547a7", "hex").copy(TOKEN_KEY, 0, 0, 16);

/*
async function sample_code() {
    const { XToken } = require("pp-dbapi/XToken");

    let opts = { plain: false };
    let src = { "foo": "bar" };
    let dst = "tN7gR3IaNOYE9O5uivXgYy2Pcrcz-54MdKIk-3TwYBGLyCJMu-6ZMLbxQg64vnfV8H0HwidiE7fAGHo-o0_1wCM7RNpINEvjucdbE7Lf_0k";
    let r = {
        enc: src && await XToken.encode(opts, src),
        dec: dst && await XToken.decode(opts, dst),
        e_d: src && await XToken.decode(opts, (await XToken.encode(opts, src)).token),
        d_e: dst && await XToken.encode(opts, (await XToken.decode(opts, dst)).data),
    };

    console.log({ src, dst, ...r });
};
*/

const {
    PollenError,
} = require("utils");

const {
    invalidToken,
    sessionExpired,
} = require('messages');


const pxlib = {
    access  : eval(process.env.accessExpiry     || 9 * 24 * 60 * 60 * 1000), // 9 days
    session : eval(process.env.sessionExpiry    ||           5 * 60 * 1000), // 5 minutes
    otp     : eval(process.env.otpExpiry        ||           2 * 60 * 1000), // 2 minutes
    refresh : eval(process.env.refreshExpiry    || 90* 24 * 60 * 60 * 1000), // 90 days
};
pxlib.default = pxlib.session;

const cipher_algorithm = "aes-128-gcm";
const cipher_ivLength = 16;
const cipher_authTagLength = 16;

const SafeSet = {
    /**
    * url-friendly base64-encode
    * expects Buffer as input
    */
    encode(buf) {
        return buf.toString("base64").replace(/[+/=]/g, (m) => ({"+":"-","/":"_","=":""})[m[0]]);
    },

    /**
    * url-friendly base64-decode
    * expects String as input
    */
    decode(str) {
        return Buffer.from(String(str).replace(/[-_]/g, (m) => ({"-":"+","_":"/"})[m[0]]), "base64");
    },
};


class XToken {

    static pxlib(px) {
        if (Number.isInteger(px) && px > 0) return px;
        return pxlib[px]; // || pxlib.default
    }

    static async encode(opts, data) {
        // data.phone
        // data.email
        // data.pass_temp
        // data may be anything json-encodeable

        // let token = crypto.randomBytes(64);

        const {
            raw = false, // output Buffer instead of safeset-string
            plain = false, // do not proceed encryption
            ts = Date.now(),
            px = pxlib.default,
        } = opts || {};

        if (!Number.isInteger(ts) || !(ts > 0)) throw new Error("Invalid ts value");
        if (!Number.isInteger(px) || !(px > 0)) throw new Error("Invalid px value");

        const key = TOKEN_KEY;

        const meta = { ts, px };
        const full = [meta, data];
        const body = JSON.stringify(full);

        let dst;
        if (plain) {
            dst = Buffer.from(body, "utf8");
        }
        else {
            do {
                const iv = crypto.randomBytes(cipher_ivLength);
                const cipher = crypto.createCipheriv(cipher_algorithm, key, iv, { authTagLength: cipher_authTagLength });
                dst = Buffer.concat([
                    iv,
                    cipher.update(body, "utf8"), cipher.final(),
                    cipher.getAuthTag(),
                ]);
            } while (0);
        }

        return {
            meta,
            token: raw ? dst : SafeSet.encode(dst),
        };
    };

    static async decode(opts, token) {

        const {
            plain = false, // do not proceed decryption
        } = opts || {};

        const key = TOKEN_KEY;
        const src = Buffer.isBuffer(token) ? token : SafeSet.decode(token);

        let body, full;
        try {

            if (plain) {
                body = src.toString("utf8");
            }
            else {
                const iv = src.slice(0, cipher_ivLength);
                const decipher = crypto.createDecipheriv(cipher_algorithm, key, iv, { authTagLength: cipher_authTagLength });
                decipher.setAuthTag(src.slice(-cipher_authTagLength));
                body = decipher.update(src.slice(cipher_ivLength, -cipher_authTagLength), null, "utf8") + decipher.final("utf8");
            }
            full = JSON.parse(body);
        }
        catch (err) {
            console.error(err, { opts, token, src });
            //throw new Error("Invalid Token", { cause: err });
            throw new PollenError(invalidToken, { cause: err });
        }

        const [meta, data] = full;
        const { ts, px } = meta;

        if (ts + px < Date.now()) {
            //throw new Error("Expired Token");
            throw new PollenError(sessionExpired);
        }

        return {
            meta,
            data,
        };
    };

    /**
    * create 6-digit one-time password
    */
    static async mk_otp_phone() {
        return String(crypto.randomInt(100000, 1000000));
    }
};

Object.assign(module.exports, {
    XToken,
});
