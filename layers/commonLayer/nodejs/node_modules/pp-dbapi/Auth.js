
const MODE = process.env.mode || "mock";

const crypto = require("crypto");

const mysql_client = require('pp-mysql/client');
const {
    Q, q,
    $exe,
    $tbl,
    $row,
    $one,
} = mysql_client.shorthands();


const { XToken } = require("./XToken");
const { User } = require("./User");
const { UserPhone } = require("./UserPhone");


const { postToken, publishSMS } = require('aws-layer');
const { UserClient } = require('aws-layer');

const {
    PollenError,
} = require("utils");

const {
    wrongOTP,
    userDoesNotExist,
    OTPSMS,
} = require('messages');


class Auth {
    /**
    * login (optionally register), 1-staged
    */
    static async logreg1(ctx, data) {
        const { } = ctx || {}; // unused

        const {
            phone: phone_raw,
            // email,
            pass_user,
        } = data;

        throw new Error("Not implemented");
    }

    /**
    * login (optionally register), 2-staged, 1st stage
    */
    static async logreg21(ctx, data) {
        const { } = ctx || {}; // unused

        let {
            phone: phone_raw,
            // email: email_raw, // not implemented
        } = data;

        // validate/normalize phone
        const { phone } = await UserPhone.normalize_phone(phone_raw, { throw_invalid: true });

        // TODO check throttling for the phone

        // create token with phone and pass_temp
        const pass_temp = await XToken.mk_otp_phone();
        const token_sess_data = {
            phone,
            pass_temp
        };
        const {
            meta: token_sess_meta,
            token: token_sess,
        } = await XToken.encode({ px: XToken.pxlib("otp") }, token_sess_data);

        // send pass_temp_expect to the supplied phone number via sms (should be optional here? shoud it be here at all? definitely, should not depend on env...)
        if (MODE != "mock") {
            publishSMS(phone, OTPSMS(pass_temp, token_sess_meta.px));
        }

        // return token, token_data
        // (only token should be exposed to the user)
        return {
            token_sess,
            token_sess_data,
        };
    }

    /**
    * login (optionally register), 2-staged, 2nd stage
    */
    static async logreg22(ctx, data) {
        const { } = ctx || {}; // unused

        const {
            token_sess,
            pass_temp,
        } = data;

        // decrypt token, extract phone (email, ...) and extract (or either lookup using this token or calculate or anything) pass_temp(_expect)
        const {
            meta: token_sess_meta,
            data: token_sess_data,
        } = await XToken.decode({}, token_sess);

        const {
            phone,
            // email, // not implemented
            pass_temp: pass_temp_expect
        } = token_sess_data;

        if (pass_temp_expect !== pass_temp) {
            //throw new Error("OTP wrong");
            throw new PollenError(wrongOTP);
        }

        // case phone2user exist: proceed further
        // case phone2user does not exist: register new user_ppid, make phone confirmed and marked for login, proceed further
        // case phone2user exists but either stale or refers to foreign user: confirm phone, then throw "contact support you nasty bastard"
        let { user_ppid, user_ppid_new } = await mysql_client.$trx({}, async (conn) => {
            const dt = await conn.$one(`SELECT NOW(6)`);
            let user_phone_rows = await UserPhone.query({ conn, dt }, { phone, login: true });
            // console.log({ user_phone_rows });
            if (user_phone_rows.length > 1) {
                // for such query there might be at most 1 entry by design
                throw new Error("Internal error");
            }

            let { user_ppid } = user_phone_rows[0] || {};

            if (user_ppid) {
                // user exists, proceed
                return { user_ppid, user_ppid_new: false };
            }

            // register new user; start with user_ppid allocation
            user_ppid = (await Auth.mk_user_ppid({ conn, dt })).user_ppid;

            // this phone should not only become 'confirmed' (multiple users may have same phone 'confirmed') but also a 'login' (which doesn't allow duplicates by design)
            let r = await UserPhone.confirm_set({ conn, dt }, { user_ppid, phone });
            // if it is not so: well, registration is impossible (and transaction is implicitly rolled back due to error being thrown)
            if (!r) throw new Error("Sorry, but this phone may not be used for registration. Please, contact support.");

            await User.mk_user({ conn, dt }, { user_ppid });

            // things went well, successful registration to be signaled
            return { user_ppid, user_ppid_new: true };
        });

        // create token that allows deterministic user_ppid and login id (phone, email, ...) extraction
        const token_auth_data = {
            user_ppid,
            phone,
        };
        const {
            meta: token_auth_meta,
            token: token_auth,
        } = await XToken.encode({ px: XToken.pxlib("access") }, token_auth_data);

        // return token, user_ppid, user_ppid_new (means "new user was registered")
        return {
            token_auth,
            user_ppid,
            user_ppid_new,
        };
    }

    /**
    * login using token
    * returns user_ppid if everything is OK
    * throws on error
    */
    static async login_token(ctx, data) {
        const { } = ctx || {}; // unused

        const {
            token: token_auth,
        } = data;

        // decrypt token, extract (or either lookup using this token or calculate or anything): user_ppid, login id (phone, email, ...)
        // assert creation timestamp isn't too old to give up for the whole process (done by XToken)
        // assert ownership of login id used to create that token is still valid for that user_ppid
        // check for creation timestamp isn't too old to refresh token; if so, generate token_new
        // return user_ppid, token_new (if needed)

        const {
            meta: token_auth_meta,
            data: token_auth_data,
        } = await XToken.decode({}, token);

        const {
            user_ppid,
            phone,
            // email, // not implemented
        } = token_auth_data;

        let user_phone_rows = await UserPhone.query({}, { user_ppid, phone, login: true });
        // console.log({ user_phone_rows });
        if (user_phone_rows.length > 1) {
            // for such query there might be at most 1 entry by design
            throw new Error("Internal error");
        }

        if (!(user_phone_rows[0] || {}).user_ppid) {
            // user does not exist
            //throw new Error("Invalid token");
            throw new PollenError(userDoesNotExist);
        }

        return user_ppid;
    }


    ///**
    //* DO NOT USE register user
    //*/
    //static async register(ctx, data) {
    //    // let { conn } = ctx;
    //    let conn = ctx.conn || mysql_client;
    //
    //    const { phone, email } = data;
    //    //let { user_ppid } = data;
    //
    //    await (mysql_client || conn).$trx(async (conn) => {
    //        //await conn.$exe(`SET @now = NOW(6)`);
    //        const { user_ppid, dt } = await conn.$row(`INSERT INTO user SET user_ppid = DEFAULT, dt = DEFAULT RETURNING user_ppid, dt`);
    //    });
    //};


    /**
    * create new user (merely allocates new user_ppid)
    * returns { user_ppid, dt }
    */
    static async mk_user_ppid(ctx, data = {}) {
        const {
            conn = mysql_client,
            dt,
        } = ctx || {};

        let {
            seed,
        } = data || {};

        if (null == seed) {
            seed = crypto.randomUUID();
        }

        const user_row = await conn.$row(`
            INSERT INTO user
            SET _seed = ${conn.q(seed)}${dt == null ? `` : `, dt = ${conn.q(dt)}`}
            RETURNING user_ppid, dt
        `);

        return user_row;
    };

    //static async mk_token_otp() {}
    //static async mk_token_access() {}

};

Object.assign(module.exports, {
    Auth,
});
