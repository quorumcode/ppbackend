
const mysql_client = require('pp-mysql/client');
const {
    Q, q,
    $exe,
    $tbl,
    $row,
    $one,
} = mysql_client.shorthands();

// picks a list of keys from given object (new object is made)
//const pick = (obj, keys) => keys.reduce((r, k) => (r[k] = obj[k], r), {});
// data = pick(row, []);

const re_record = /^([^-]+)(?:-(.+))$/;
const split_record = (record) => record.match(re_record) || [, record]; //TODO old node: replace || with ??


// convert sql row to legacy data object
function User_row2data(record, row) {
    const [, record_pk, record_fk] = split_record(record);
    let data = {};
    switch (record_pk) {
        case "status":
            data = {
                user:                       row.user,
                created:                    row.created && (Number(row.created) / 1000),// legacy compat (Date => Number), SECONDS
                deleted:                    Boolean(row.deleted),                       // may be left as is safely
                blocked:                    Boolean(row.blocked),                       // may be left as is safely
                softlocked:                 Boolean(row.softlocked),                    // may be left as is safely
                KYCDate:                    row.KYCDate && (Number(row.KYCDate) / 1000),// legacy compat (Date => Number), SECONDS
                lerexKYCSubmitted:          Boolean(row.lerexKYCSubmitted),             // may be left as is safely
                idFileLink:                 row.idFileLink,
                verificationID:             row.verificationID,
                addressFileLink:            row.addressFileLink,
                addressVerificationID:      row.addressVerificationID,
                tmp_addressFileLink:        row.tmp_addressFileLink,
                tmp_addressVerificationID:  row.tmp_addressVerificationID,
                IDStatus:                   row.IDStatus,
                addressStatus:              row.addressStatus,
                identityID:                 row.identityID,
                addressIdentityID:          row.addressIdentityID,
                //_rest:                      JSON.parse(row._rest_status),
                record:                     record,                             // legacy compat
            };
            for (const f of [
                "created",
                "KYCDate",
                "idFileLink",                   // may be left as is safely
                "addressFileLink",              // may be left as is safely
                "addressVerificationID",        // may be left as is safely
                "tmp_addressFileLink",          // may be left as is safely
                "tmp_addressVerificationID",    // may be left as is safely
            ]) {
                if (null == data[f]) delete data[f];
            }
            return data;

        case "customer":
            data = {
                user:                   row.user,
                stripeID:               row.stripeID,
                lerexID:                row.lerexID,
                primaryPaymentMethod:   row.primaryPaymentMethod,
                //_rest:                  JSON.parse(row._rest_customer),
                record:                 record,                             // legacy compat
            };
            for (const f of [
                "lerexID",              // may be left as is safely
                "primaryPaymentMethod", // may be left as is safely
            ]) {
                if (null == data[f]) delete data[f];
            }
            return data;

        case "primary":
            data = {
                user:                   row.user,
                primaryStatus:          Boolean(row.primaryStatus),         // may be left as is safely
                primaryNumber:          row.primaryNumber,
                //_rest:                  JSON.parse(row._rest_primary),
                record:                 record,                             // legacy compat
            };
            return data;

        case "recovery":
            data = {
                user:                   row.user,
                recoveryStatus:         Boolean(row.recoveryStatus),        // may be left as is safely
                recoveryNumber:         row.recoveryNumber,
                //_rest:                  JSON.parse(row._rest_recovery),
                record:                 record,                             // legacy compat
            };
            return data;

        case "details":
            data = {
                user:           row.user,
                emailConfirmed: Boolean(row.emailConfirmed),          // may be left as is safely
                dob:            row.dob,
                identityId:     row.identityId,
                sex:            row.sex,
                name:           JSON.parse(row.name || "null"),
                email:          row.email,
                nickname:       row.nickname,
                address:        JSON.parse(row.address || "null"),
                profileURL:     row.profileURL,
                _rest:          JSON.parse(row._rest_details),
                record:         record,                                                         // legacy compat
            };
            //delete data._pk;
            delete data._rest;
            for (const f of [
                "dob",          // may be left as is safely
                "identityId",   // may be left as is safely
                "sex",          // may be left as is safely
                "name",         // may be left as is safely
                "nickname",     // may be left as is safely
                "address",      // may be left as is safely
            ]) {
                if (null == data[f]) delete data[f];
            }
            //for (const f of ["batch", "popular", "relevanceIndex"]) {
            //    if (null == data[f]) delete data[f];
            //    else data[f] = JSON.parse(data[f]);
            //}
            //{
            //    const f = "hidden";
            //    if (null == data[f]) delete data[f];
            //    else data[f] = Boolean(data[f]);
            //}
            return data;

        case "settings":
            data = {
                user:               row.user,
                marketing:          JSON.parse(row.marketing),
                notifications:      JSON.parse(row.notifications),
                //_rest:              JSON.parse(row._rest_settings),
                record:             record,                             // legacy compat
            };
            for (const f of [
                "marketing",        // may be left as is safely
                "notifications",    // may be left as is safely
            ]) {
                if (null == data[f]) delete data[f];
            }
            return data;

        case "wallet":
            data = {
                ...row,
                activeCard:     Boolean(row.activeCard),    // may be left as is safely
                card:           JSON.parse(row.card),
                limit:          String(row.limit),          // sometimes either string or number in legacy db
                waitlist:       Boolean(row.waitlist),      // may be left as is safely
                record: record,                             // legacy compat
                //...JSON.parse(row._rest),
            };
            delete data._pk;
            delete data._rest;
            if (row.lockTimestamp instanceof Date) data.lockTimestamp = row.lockTimestamp.toISOString(); // MAY IT BE left as is safely???
            for (const f of [
                "card",                 // may be left as is safely
                "individualAllowance",  // MAY IT BE left as is safely???
                "waitlist",             // may be left as is safely
            ]) {
                if (null == data[f]) delete data[f];
            }
            return data;

        case "paymentMethod":
            data = {
                ...row,
                pmID:               row.pmID,
                addedTimestampS:    row.addedTimestampS && (Number(row.addedTimestampS) / 1000), // legacy compat (Date => Number), SECONDS
                record: record,                             // legacy compat
                //...JSON.parse(row._rest),
            };
            delete data._pk;
            delete data._rest;
            return data;

        case "apns":
            data = {
                user:           row.user,
                // devices:     JSON.parse(row.devices), // legacy: array of tokens for each device, TBD use single token; see conversion below
                devices:        {},
                record: record,                             // legacy compat
            };
            for (const [device, token] of Object.entries(JSON.parse(row.devices) || {})) {
                data.devices[device] = [token];
            }
            return data;
    }
    throw new Error(`Unknown user record: ${record}`);
};

// convert legacy data object (may be partial) to sql row
function User_data2row(record, data) {
    const sql = (sql) => ({ toSqlString: () => sql });
    const row = {};
    for (let [field, value] of Object.entries(data)) {
        switch (field) {
            // generic
            case "user":                        break;  // as is ok
            case "created":
                // "0" means "0", column IS NOT NULLABLE
                value = Number(value);
                value = sql(`FROM_UNIXTIME(CAST(${q(value)} as DECIMAL(20, 3)))`); // not /1000 due to it is treated as SECONDS across code
                break;
            case "deleted":                     break;  // as is ok
            case "blocked":                     break;  // as is ok
            case "softlocked":                  break;  // as is ok
            case "stripeID":                    break;  // as is ok
            case "lerexID":                     break;  // as is ok
            case "primaryPaymentMethod":        break;  // as is ok
            case "primaryStatus":               break;  // as is ok
            case "primaryNumber":               break;  // as is ok
            case "recoveryStatus":              break;  // as is ok
            case "recoveryNumber":              break;  // as is ok
            case "marketing":                   value = JSON.stringify(value); break;
            case "notifications":               value = JSON.stringify(value); break;
            case "emailConfirmed":              break;  // as is ok
            case "dob":                         break;  // as is ok
            case "identityId":                  break;  // as is ok
            case "sex":                         break;  // as is ok
            case "name":                        value = JSON.stringify(value); break;
            case "email":                       break;  // as is ok
            case "nickname":                    break;  // as is ok
            case "profileURL":                  break;
            case "address":                     value = JSON.stringify(value); break;
            case "IDStatus":                    break;
            case "addressStatus":               break;
            case "KYCDate":
                // "0" means "null", column IS NULLABLE
                value = Number(value) || null;
                value = sql(`FROM_UNIXTIME(CAST(${q(value)} as DECIMAL(20, 3)))`); // not /1000 due to it is treated as SECONDS in the code
                break;
            case "lerexKYCSubmitted":           break;  // as is ok
            case "idFileLink":                  break;  // as is ok
            case "verificationID":              break;  // as is ok
            case "identityID":                  break;  // as is ok
            case "addressFileLink":             break;  // as is ok
            case "addressVerificationID":       break;  // as is ok
            case "addressIdentityID":           break;  // as is ok
            case "tmp_addressFileLink":         break;  // as is ok
            case "tmp_addressVerificationID":   break;  // as is ok

            // wallet
            case "limit":                       break;  // as is ok
            case "individualAllowance":         break;  // as is ok
            case "activeCard":                  break;  // as is ok
            case "card":                        value = JSON.stringify(value); break;
            case "lockTimestamp":               value = (value instanceof Date) ? value : sql(`STR_TO_DATE(${q(value)}, '%Y-%m-%dT%T.%fZ')`); break; // used like (new Date().toISOString()) across code
            case "waitlist":                    break;  // as is ok

            // paymeth
            case "pmID":                        break; // as is ok
            case "addedTimestampS":
                // "0" means "0", column IS NOT NULLABLE
                value = Number(value);
                value = sql(`FROM_UNIXTIME(CAST(${q(value)} as DECIMAL(20, 3)))`); // not /1000 due to it is treated as SECONDS across code
                break;
            case "type":                        break; // as is ok
            case "digits":                      break; // as is ok
        }
        row[field] = value;
    }
    return row;
};


class UserClientMySQL {
    constructor(userName) {
        this.userName = userName; // legacy
        this.userID = Number(userName);
    };

    // to be deprecated though
    static async scan() {
//            const scan = await dynamo.scan({
//              TableName: TABLE
//            }).promise()
//            return scan
    };

    // alternative construct: using lerexID
    static async fromLerexID(lerexID) {
        const row = await $row(`
            SELECT ${Q("user")} as ${Q("userName")}, ${Q("deleted")}
            FROM ${Q("user_generic")}
            WHERE ${Q("lerexID")} = ${q(lerexID)}
        `);
        let { userName, deleted } = row || {};
        if (deleted) {
            console.warn("WARNING: not returning deleted user", { func: "fromLerexID", lerexID, row });
            userName = null;
        }
        return {
              userTable: new this(userName),
              userName,
        };
    };

    // alternative construct: using verificationID
    static async fromVerificationID(verificationID, verificationProp = 'verificationID') {
        const row = await $row(`
            SELECT ${Q("user")} as ${Q("userName")}, ${Q("deleted")}
            FROM ${Q("user_generic")}
            WHERE ${Q(verificationProp)} = ${q(verificationID)}
        `);
        let { userName, deleted } = row || {};
        if (deleted) {
            console.warn("WARNING: not returning deleted user", { func: "fromVerificationID", verificationID, row });
            userName = null;
        }
        return {
              userTable: new this(userName),
              userName,
        };
    };

    // was exported separately (exports.handleSecondary)
    static async handleSecondary(submittedNumber) {
        const row = await $row(`
            SELECT ${Q("user")}, ${Q("recoveryStatus")}, ${Q("deleted")}
            FROM ${Q("user_generic")}
            WHERE ${Q("user")} = ${q(Number(submittedNumber))}
        `);
        if (row && row.deleted) {
            console.warn("WARNING: mangling deleted user as non-existent", { func: "handleSecondary", submittedNumber, row });
        }
        return (row && !row.deleted)
            ? { userName: row.user, numberConfirmed: row.recoveryStatus }
            : { userName: submittedNumber, numberConfirmed: true }
        ;
    };

    static async emailConfirmed(email) {
        const row = await $row(`
            SELECT ${Q("emailConfirmed")}, ${Q("deleted")}
            FROM ${Q("user_generic")}
            WHERE ${Q("email")} = ${q(email)}
        `);
        if (row && row.deleted) {
            console.warn("WARNING: not returning deleted user", { func: "emailConfirmed", email, row });
        }
        return Boolean(row && !row.deleted && row.emailConfirmed);
    };

    async fetch(record) {
        const r = await this.query(record);
        return r.Items[0];
    };

    async queryStrict(record = 'paymentMethod') {
        const [, record_pk, record_fk] = split_record(record);
        if ((record_pk == "paymentMethod") && !record_fk) throw new Error(`Called queryStrict() with partial record specified (${record})`);
        return /*await*/ this.query(record);
    };

    async query(record = 'details') {
        // FYI: originally it queries with KeyConditionExpression: '#user = :user and begins_with (#rec, :rec)'
        const [, record_pk, record_fk] = split_record(record);
        let sql = "";
        switch (record_pk) {
            case "status":
            case "customer":
            case "primary":
            case "recovery":
            case "details":
            case "settings":
                sql = `
                    SELECT ug.*
                    FROM ${Q("user_generic")} as ug
                    WHERE 1
                        AND ug.${Q("user")} = ${q(this.userID)}
                        AND !ug.deleted
                `;
                break;
            case "wallet":
                sql = `
                    SELECT uw.*
                    FROM
                        ${Q("user_wallet")} as uw
                        LEFT JOIN ${Q("user_generic")} as ug ON ug.${Q("user")} = uw.${Q("user")}
                    WHERE 1
                        AND uw.${Q("user")} = ${q(this.userID)}
                        /* AND ((ug.deleted IS NULL) OR !ug.deleted) */
                `;
                break;
            case "paymentMethod": // paymentMethod-... (optionally multiple records)
                sql = `
                    SELECT up.*
                    FROM
                        ${Q("user_paymeth")} as up
                        LEFT JOIN ${Q("user_generic")} as ug ON ug.${Q("user")} = up.${Q("user")}
                    WHERE 1
                        AND up.${Q("user")} = ${q(this.userID)}
                        /* AND ((ug.deleted IS NULL) OR !ug.deleted) */
                `;
                if (null != record_fk) sql += ` AND up.${Q("pmID")} = ${q(record_fk)}`;
                break;
            case "apns": // single row with nested data (legacy artifact)
                sql = `
                    SELECT user, json_detailed(JSON_OBJECTAGG(device, token)) as devices
                    FROM user_device_token
                    WHERE ${Q("user")} = ${q(this.userID)}
                    GROUP BY user
                `;
                break;
            default:
                throw new Error(`Unknown user record: ${record}`);
        }

        const results = (await $tbl(sql)).map(row => User_row2data(record, row));
        return {
            Items: results, // .map(XXX_row2data)
            Count: results.length, // legacy compat
        };
    };

    async exists(record = 'details') {
        //const { Count } = await this.queryStrict(record);
        //return Boolean(Count);
        const [, record_pk, record_fk] = split_record(record);
        let sql = "";
        switch (record_pk) {
            case "status":
                sql = `
                    SELECT COALESCE(${Q("verificationID")}, ${Q("softlocked")}) IS NOT NULL as xx
                    FROM ${Q("user_generic")} as ug
                    WHERE ug.${Q("user")} = ${q(this.userID)} AND !ug.deleted
                `;
                break;
            case "customer":
                sql = `
                    SELECT COALESCE(${Q("stripeID")}, ${Q("lerexID")}, ${Q("primaryPaymentMethod")}) IS NOT NULL as xx
                    FROM ${Q("user_generic")} as ug
                    WHERE ug.${Q("user")} = ${q(this.userID)} AND !ug.deleted
                `;
                break;
            case "primary":
                sql = `
                    SELECT ${Q("primaryNumber")} IS NOT NULL as xx
                    FROM ${Q("user_generic")} as ug
                    WHERE ug.${Q("user")} = ${q(this.userID)} AND !ug.deleted
                `;
                break;
            case "primary":
                sql = `
                    SELECT ${Q("recoveryNumber")} IS NOT NULL as xx
                    FROM ${Q("user_generic")} as ug
                    WHERE ug.${Q("user")} = ${q(this.userID)} AND !ug.deleted
                `;
                break;
            case "details":
                sql = `
                    SELECT COALESCE(${Q("dob")}, ${Q("identityId")}, ${Q("sex")}, ${Q("name")}, ${Q("email")}, ${Q("nickname")}, ${Q("address")}) as xx
                    FROM ${Q("user_generic")} as ug
                    WHERE ug.${Q("user")} = ${q(this.userID)} AND !ug.deleted
                `;
                break;
            case "settings":
                sql = `
                    SELECT COALESCE(${Q("marketing")}, ${Q("notifications")}) as xx
                    FROM ${Q("user_generic")} as ug
                    WHERE ug.${Q("user")} = ${q(this.userID)} AND !ug.deleted
                `;
                break;
            case "wallet":
                sql = `
                    SELECT 1 as xx
                    FROM ${Q("user_wallet")}
                    WHERE ${Q("user")} = ${q(this.userID)}
                `;
                break;
            case "paymentMethod": // paymentMethod-... (optionally multiple records)
                sql = `
                    SELECT 1 as xx
                    FROM ${Q("user_paymeth")}
                    WHERE ${Q("user")} = ${q(this.userID)}
                    LIMIT 1
                `;
                if (null != record_fk) sql += ` AND ${Q("pmID")} = ${q(record_fk)}`;
                break;
            case "apns": // single row with nested data (legacy artifact)
                sql = `
                    SELECT 1 as xx
                    FROM user_device_token
                    WHERE ${Q("user")} = ${q(this.userID)}
                    LIMIT 1
                `;
                break;
            default:
                throw new Error(`Unknown user record: ${record}`);
        }

        const r = await $one(sql);
        return Boolean(r);
    };

    // === wrappers below === (mostly unmodified from legacy userTable.js)

    async details() {
        const details = await this.queryStrict('details');
        return details.Items[0];
    };

    async settings() {
        const settings = await this.queryStrict('settings');
        return settings.Items[0];
    };

    async primary() {
        const primary = await this.queryStrict('primary');
        return primary.Items[0];
    };

    async recovery() {
        const recovery = await this.queryStrict('recovery');
        return recovery.Items[0];
    };

    async status() {
        const status = await this.queryStrict('status');
        return status.Items[0];
    };

    async customer() {
        const customer = await this.queryStrict('customer');
        return customer.Items[0];
    };

    async apns() {
        const { Count, Items } = await this.queryStrict('apns');
        return (Count ? Items[0] : { devices: {} })
    };

    async paymentMethod() {
        const paymentMethod = await this.query('paymentMethod');
        return {
            count: paymentMethod.Count,     // originally lo-case key (???)
            items: paymentMethod.Items,     // originally lo-case key (???)
        };
    };

    async wallet () {
        const wallet = await this.queryStrict('wallet')
        if (wallet.Count == 0) { return { activeCard: false }}; // why it is so (activeCard mentioned instead of just an empty object)?
        return wallet.Items[0]
    };

    // to be cut.
    // used in single place: cards/helpers.js, setPrimary(...): .updateField('customer', 'primaryPaymentMethod', pmID)
    async updateField(record, field, val) {
        await this.updateMultipleFields(record, { [field]: val });
    };

    // TO BE TESTED
    async updateMultipleFields(record, payload) {
        const [, record_pk, record_fk] = split_record(record);
        let tbl = "";
        switch (record_pk) {
            case "status":              //          loans/wallet.js users/update.js loans/metamapLayer.js kyc/getResource.js
            case "customer":            //          loans/wallet.js users/update.js
            case "primary":             // unused?
            case "recovery":            //          ?
            case "details":             //          users/emailConfirmation/index.js
            case "settings":            // unused?
                tbl = "user_generic";
                break;
            case "wallet":              //          loans/wallet.js users/helpers.js
                tbl = "user_wallet";
                break;
            case "paymentMethod":       // unused?
                tbl = "user_paymeth";
                break;

            case "apns":                // unused?
                tbl = "user_device_token";
                throw new Error(`Not supported: ${record} (updateMultipleFields)`);
                return;

            default:
                throw new Error(`Unknown user record: ${record} (updateMultipleFields)`);
        }


        //const row = { ...payload };
        //const sql = `UPDATE ${Q(tbl)} SET ${q(row)} WHERE ${Q("user")} = ${q(this.userID)}`;

        const row = User_data2row(record, { ...payload });
        if (!Object.keys(row).length) return; // nothing to do

        const sql = `INSERT INTO ${Q(tbl)} SET ${Q("user")} = ${q(this.userID)}, ${q(row)} ON DUPLICATE KEY UPDATE ${q(row)}`;

        await $exe(sql);
    };

    // TO BE DEPRECATED, used just @ a couple of places
    async putRecord(record, payload) {
        const [, record_pk, record_fk] = split_record(record);
        switch (record_pk) {
            case "status":
                // users/update.js
                // kyc/getResource.js
                return this.updateMultipleFields(record, payload);

            case "customer":        break; // unused
            case "primary":         break; // unused
            case "recovery":        break; // unused?
            case "details":         break; // unused
            case "settings":        break; // unused
            case "wallet":          break; // unused
            case "paymentMethod":
                // cards/addNew.js
                return this.updateMultipleFields(record, { pmID: record_fk, ...payload });
            case "apns":
                // users/postPushToken/index.js
                if (!payload.devices) return; // should delete?
                for (let [device, tokens] of Object.entries(payload.devices)) {
                    const token = tokens[tokens.length - 1];
                    const sql = `REPLACE INTO ${Q("user_device_token")} (user, device, token) VALUES (${q(this.userID)}, ${q(device)}, ${q(token)})`;
                    await $exe(sql);
                }
                return;
        }
        throw new Error(`Unknown user record: ${record} (putRecord)`);
    };

    // DEPRECATED for now (totally unused)
    async deleteRecord(record) {
        throw new Error(`UserClient.deleteRecord is deprecated (record: ${record}).`);
/*
        const [, record_pk, record_fk] = split_record(record);
        let sql = "";
        switch (record) {
            case "status":
            case "customer":
            case "primary":
            case "recovery":
            case "details":
            case "settings":
                // ...
                break;
            case "wallet":
                sql = `DELETE FROM ${Q("user_wallet")} WHERE ${Q("user")} = ${q(this.userID)}`;
                break;
            case "paymentMethod": // paymentMethod-...
                // ...
                break;
            case "apns":
                // ...
                break;
            default:
                throw new Error(`Unknown user record: ${record}`);
        }

        throw new Error(`REJECTED Unsafe operation: ${sql}`);

        await $exe(sql);
*/
    };

    async deletePaymentMethodRecord(pmID) {
        const sql = `DELETE FROM ${Q("user_paymeth")} WHERE ${Q("user")} = ${q(this.userID)} AND ${Q("pmID")} = ${q(pmID)}`;
        await $exe(sql);
    };
};

// LEGACY client
const UserClientDynamo = require('aws-layer/dynamo/userTable').UserClient;

Object.assign(UserClientDynamo, { dynamo: UserClientDynamo, mysql: UserClientMySQL });
Object.assign(UserClientMySQL, { dynamo: UserClientDynamo, mysql: UserClientMySQL });

Object.assign(module.exports, {
    UserClientMySQL,
    UserClientDynamo,
    UserClient: ["prod", "test"].includes(process.env.mode) ? UserClientMySQL : UserClientDynamo,
});
