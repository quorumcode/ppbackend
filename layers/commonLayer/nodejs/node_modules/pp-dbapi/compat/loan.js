
const mysql_client = require('pp-mysql/client');

const {
    Q, q, qlike,
    $exe,
    $tbl,
    $one,
} = mysql_client.shorthands();


// convert sql row to legacy data object
function Loan_row2data(row) {
    const data = {
        ...row,
        created: Number(row.created),                                       // legacy compat (Date => Number)
        archived: Number(row.archived),                                     // legacy compat (Date => Number + implicit null => 0 conversion)
        transactions: JSON.parse(row.transactions),
        overdue: Boolean(row.overdue),                                      // legacy compat (0|1 => false|true)
        items: JSON.parse(row.items),
        customItems: JSON.parse(row.customItems),
        delayAdvancePayment: JSON.parse(row.delayAdvancePayment),
        //...JSON.parse(row._rest),
    };
    delete data._pk;
    delete data._rest;
    if (null == data.merchantID) data.merchantID = false;                   // legacy compat
    if (null == data.paymentMethod) delete data.paymentMethod;
    if (null == data.otherMerchant) data.otherMerchant = false;             // legacy compat
    if (null == data.deleted) delete data.deleted;
    else data.deleted = Boolean(data.deleted);                              // legacy compat
    if (null == data.delayAdvancePayment) delete data.delayAdvancePayment;
    if (null == data.individualAllowance) delete data.individualAllowance;
    return data;
};

// convert legacy data object (may be partial) to sql row
function Loan_data2row(data) {
    const sql = (sql) => ({ toSqlString: () => sql });
    const row = {};
    for (let [field, value] of Object.entries(data)) {
        switch (field) {
            case "archived":
                // "0" means "null", column is nullable
                value = Number(value) || null;
                value = sql(`FROM_UNIXTIME(CAST(${q(value)} as DECIMAL(20, 3)) / 1000)`);
                break;

            case "created":
                // "0" means "0", column is not nullable
                value = Number(value);
                value = sql(`FROM_UNIXTIME(CAST(${q(value)} as DECIMAL(20, 3)) / 1000)`);
                break;

            case "transactions":
            case "items":
            case "customItems":
            case "delayAdvancePayment":
                value = JSON.stringify(value);
                break;

            case "overdue":
                //value = Boolean(value);
                break;

            case "merchantID":
                if (false === value) value = null;
                break;

            case "otherMerchant":
                if (false === value) value = null;
                break;

            //case "paymentMethod":
            //case "deleted":
            //case "individualAllowance":

        }
        row[field] = value;
    }
    return row;
};


class LoanClientMySQL {
    constructor(userName) {
        this.userName = userName; // legacy
        this.userID = Number(userName);
    };

    // having user, query loan records
    // possible cases for loanStateID:
    //  "" // all
    //  "1638698526296" // specific, including all archived variants
    //  "1638698526296-XuVrCKhnQ1IeNG8hkT0b4" // single specific record
    // real cases can't be investigated, loanStateID may come as unfiltered lambda parameter
    // so can't collapse `LIKE xxx%` to `= xxx`
    // returns { Items: [...rows] }
    // throws on any error
    async query(loanStateID) {
        const sql = `
            SELECT *
            FROM ${Q("loan")}
            WHERE 1
                AND ${Q("userID")} = ${q(this.userID)}
                AND ${Q("loanStateID")} LIKE ${q(qlike(loanStateID) + "%")}
        `;
        const results = await $tbl(sql);
        return {
            Items: results.map(Loan_row2data),
            Count: results.length, // legacy compat
        };
    };

    // having user, query actual ("non-archived") loan records
    // returns [...rows]
    // throws on any error
    async getNonArchivedStates() {
        const sql = `
            SELECT *
            FROM ${Q("loan")}
            WHERE 1
                AND ${Q("userID")} = ${q(this.userID)}
                AND ${Q("archived")} IS NULL
        `;
        const results = await $tbl(sql);
        return results.map(Loan_row2data);
    };

    // what fields are allowed for update?
    // what to do if no such row? should we insert ... on dup key update?
    // should there be a protection to disallow updating archived records?
    // should it return a thing or just throw on error?
    // (returns nothing in legacy code)
    // returns nothing
    // throws on any error (e.g. sql error for unknown/invalid field)
    async updateField(loanStateID, field, val) {
        const row = Loan_data2row({ [field]: val });
        const sql = `
            UPDATE ${Q("loan")}
            SET ${q(row)}
            WHERE 1
                AND ${Q("userID")} = ${q(this.userID)}
                AND ${Q("loanStateID")} = ${q(loanStateID)}
                # AND ${Q("archived")} IS NULL
        `;
        await $exe(sql);
    };

    // make a record archived
    // NOTE: if there is a row duplication under the hood somewhere and this functions' purpose is
    // NOTE: to make "old" row archived => the whole thing must be wrapped with transaction.
    // (returns nothing in legacy code)
    // returns nothing
    // throws on any error (e.g. sql error for unknown/invalid field)
    async archiveLoanState(loanStateID) {
        await this.updateField(loanStateID, 'archived', Date.now());
    };

    // dynamo.put acts like REPLACE indeed, but it is intentionally INSERT here
    // returns nothing in legacy code
    // throws sql error on unknown/invalid field
    async putState(loanStateID, payload) {
        const row = Loan_data2row({
            userID: this.userID,
            loanStateID,
            ...payload,
        });
        const sql = `INSERT INTO ${Q("loan")} SET ${q(row)}`;
        await $exe(sql);
    };
};

// LEGACY client
const LoanClientDynamo = require('aws-layer/dynamo/loanTable').LoanClient;

Object.assign(LoanClientDynamo, { dynamo: LoanClientDynamo, mysql: LoanClientMySQL });
Object.assign(LoanClientMySQL, { dynamo: LoanClientDynamo, mysql: LoanClientMySQL });

Object.assign(module.exports, {
    LoanClientMySQL,
    LoanClientDynamo,
    LoanClient: ["prod", "test"].includes(process.env.mode) ? LoanClientMySQL : LoanClientDynamo,
});
