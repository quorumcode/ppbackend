
const mysql_client = require("pp-mysql/client");
const {
    Q, q,
    $exe,
    $tbl,
    $one,
} = mysql_client.shorthands();


const re_record = /^([^-]+)(?:-(.+))$/;
const split_record = (record) => record.match(re_record) || [, record]; //TODO old node: replace || with ??


// convert sql row to legacy data object
function Merchant_row2data(record, row) {
    const [, record_pk, record_fk] = split_record(record);
    let data = {};
    switch (record_pk) {
        case "details":
            data = {
                ...row,
                deal: JSON.parse(row.deal),
                direct: JSON.parse(row.direct),
                inStore: Boolean(row.inStore),
                location: JSON.parse(row.location),
                online: Boolean(row.online),
                parent: JSON.parse(row.parent),
                subcategory: JSON.parse(row.subcategory),
                contactDetails: JSON.parse(row.contactDetails),
                record: record,                                                         // legacy compat
                //...JSON.parse(row._rest),
            };
            delete data._pk;
            delete data._rest;
            for (const f of ["deal", "contactDetails"]) {
                if (null == data[f]) delete data[f];
            }
            for (const f of ["batch", "popular", "relevanceIndex"]) {
                if (null == data[f]) delete data[f];
                else data[f] = JSON.parse(data[f]);
            }
            for (const f of ["hidden", "allowCustomAmounts"]) {
                if (null == data[f]) delete data[f];
                else data[f] = Boolean(data[f]);
            }

            if (!data.logoURL && data.logo_fn) data.logoURL = "https://client-assets-pp03uat.s3.eu-west-2.amazonaws.com/" + encodeURIComponent(data.logo_fn);
            else if (!data.logoURL) data.logoURL = "";
            delete data.logo_fn;

            if (!data.imageURL && data.image_fn) data.imageURL = "https://client-assets-pp03uat.s3.eu-west-2.amazonaws.com/" + encodeURIComponent(data.image_fn);
            else if (!data.imageURL) data.imageURL = "";
            delete data.image_fn;

            return data;

        case "user":
            data = {
                ...row,
                billing: JSON.parse(row.billing),
                record: record,                                                         // legacy compat
                //...JSON.parse(row._rest),
            };
            delete data._pk;
            delete data._rest;
            for (const f of ["batch", "settlements"]) {
                if (null == data[f]) delete data[f];
                else data[f] = JSON.parse(data[f]);
            }
            return data;

        // test DB version only:
        case "location": // "location-1"
            data = {
                ...row,
                record: record, // row._record,                                         // legacy compat
                lat: +row.lat,                                                          // legacy compat
                lng: +row.lng,                                                          // legacy compat
                //...JSON.parse(row._rest),
            };
            delete data._pk;
            delete data._rest;
            delete data._record;
            return data;

        case "product": // "product-LugiCz2X"
            data = {
                ...row,
                record: record,                                                    // legacy compat
                //...JSON.parse(row._rest),
            };
            delete data._pk;
            delete data._rest;
            return data;

        case "productGroup": // "productGroup-gKpIJT4O"
            data = {
                ...row,
                record: record,                                                    // legacy compat
                //...JSON.parse(row._rest),
            };
            delete data._pk;
            delete data._rest;
            return data;
    }
    throw new Error(`Unknown merchant record: ${record}`);
};

// convert legacy data object (may be partial) to sql row
function Merchant_data2row(record, data) {
    const row = { ...data };
    return row;
};


class MerchantClientMySQL {
    constructor(merchantID) {
        this.merchant = merchantID; // legacy
        //Object.assign(this, { merchant: merchantID })
    }

    // to be deprecated though
    async scan(table = MERCHANT_TABLE) {
//                    const scan = await dynamo.scan({
//                        TableName: table
//                    }).promise()
//                    return scan
    }

    async query(record = "details") {
        const [, record_pk, record_fk] = split_record(record);
        let sql = "";
        switch (record_pk) {
            case "details":
                sql = `SELECT * FROM ${Q("merchant")} WHERE ${Q("merchant")} = ${q(this.merchant)}`;
                break;
            case "user":
                sql = `SELECT * FROM ${Q("merchant_user")} WHERE ${Q("merchant")} = ${q(this.merchant)}`;
                break;
            case "location": // "location-1"
                sql = `SELECT * FROM ${Q("merchant_location")} WHERE ${Q("merchant")} = ${q(this.merchant)}`;
                if (null != record_fk) sql += ` AND ${Q("_record")} = ${q(record)}`;
                break;
            case "product": // "product-LugiCz2X"
                sql = `SELECT * FROM ${Q("merchant_product")} WHERE ${Q("merchant")} = ${q(this.merchant)}`;
                if (null != record_fk) sql += ` AND ${Q("productID")} = ${q(record_fk)}`;
                break;
            case "productGroup": // "productGroup-gKpIJT4O"
                sql = `SELECT * FROM ${Q("merchant_productgroup")} WHERE ${Q("merchant")} = ${q(this.merchant)}`;
                if (null != record_fk) sql += ` AND ${Q("productGroupID")} = ${q(record_fk)}`;
                break;
            case "campaign":
                //TODO investigate
                sql = `SELECT NULL LIMIT 0`;
                break;
            default:
                throw new Error(`Unknown merchant record: ${record}`);
        }

        const results = (await $tbl(sql)).map(row => Merchant_row2data(record, row));
        return {
            Items: results, // .map(XXX_row2data)
            Count: results.length, // legacy compat
        };
    }

    //TODO rewrite
    async exists(record = "details") {
        const { Count } = await this.query(record);
        return !!(Count)
    }

    async getProductGroups() {
        const query = await this.query("productGroup");
        return query;
    }

    async getProducts() {
        // this will NOT double-count productGroups, there is no need to query "product-"
        const query = await this.query("product");
        return query;
    }

    async getUser() {
        const { Items } = await this.query("user");
        return Items[0];
    }

    static async getCategory(category = 0) {
        const sql = `
            SELECT *
            FROM ${Q("merchant")}
            WHERE ${Q("category")} = ${q(category)}
        `;

        //return await $tbl(sql);

        const results = (await $tbl(sql)).map(row => Merchant_row2data("details", row));
        //return {
        //    Items: results, // .map(XXX_row2data)
        //    Count: results.length, // legacy compat
        //};
        return results;
    }

    async updateField(record, field, val) {
        await this.updateMultipleFields(record, { [field]: val });
    }

    // what to do if no such row? should we insert ... on dup key update?
    // TO BE TESTED
    async updateMultipleFields(record, payload) {
        const [, record_pk, record_fk] = split_record(record);
        let tbl = "";
        let row = Merchant_data2row({
            ...payload,
        });
        let sql_where = `${Q("merchant")} = ${q(this.merchant)}`
        switch (record_pk) {
            case "details":
                tbl = "merchant";
                break;
            case "user":
                tbl = "merchant_user";
                break;
            case "location": // "location-1"
                if (null == record_fk) throw new Error(`Unable to update using partial record spec: ${record}`);
                tbl = "merchant_location";
                sql_where += ` AND ${Q("_record")} = ${q(record)}`;
                break;
            case "product": // "product-LugiCz2X"
                if (null == record_fk) throw new Error(`Unable to update using partial record spec: ${record}`);
                tbl = "merchant_product";
                sql_where += ` AND ${Q("productID")} = ${q(record_fk)}`;
                break;
            case "productGroup": // "productGroup-gKpIJT4O"
                if (null == record_fk) throw new Error(`Unable to update using partial record spec: ${record}`);
                tbl = "merchant_productgroup";
                sql_where += ` AND ${Q("productGroupID")} = ${q(record_fk)}`;
                break;
            default:
                throw new Error(`Unknown merchant record: ${record}`);
        }

        const sql = `UPDATE ${Q(tbl)} SET ${q(row)} WHERE ${sql_where}`;

        //TODO
        throw new Error(`REJECTED Unsafe operation: ${sql}`);

        await $exe(sql);
    }

    // should it REALLY replace things on collision?
    // maybe it should be an INSERT, not a REPLACE?
    async putRecord(record, payload) {
        const [, record_pk, record_fk] = split_record(record);
        let tbl = "";
        let row = Merchant_data2row({
            merchant: this.merchant,
            ...payload
        });
        switch (record_pk) {
            case "details":
                tbl = "merchant";
                break;
            case "user":
                tbl = "merchant_user";
                break;
            case "location": // "location-1"
                if (null == record_fk) throw new Error(`Unable to replace using partial record spec: ${record}`);
                tbl = "merchant_location";
                row._record = record;
                break;
            case "product": // "product-LugiCz2X"
                if (null == record_fk) throw new Error(`Unable to replace using partial record spec: ${record}`);
                tbl = "merchant_product";
                row.productID = record_fk;
                break;
            case "productGroup": // "productGroup-gKpIJT4O"
                if (null == record_fk) throw new Error(`Unable to replace using partial record spec: ${record}`);
                tbl = "merchant_productgroup";
                row.productGroupID = record_fk;
                break;
            default:
                throw new Error(`Unknown merchant record: ${record}`);
        }

        const sql = `REPLACE INTO ${Q(tbl)} SET ${q(row)}`;

        //TODO
        throw new Error(`REJECTED Unsafe operation: ${sql}`);

        await $exe(sql);
    }

    async remove(record) {
        const [, record_pk, record_fk] = split_record(record);
        let tbl = "";
        let row = { ...payload };
        let sql_where = `${Q("merchant")} = ${q(this.merchant)}`
        switch (record_pk) {
            case "details":
                tbl = "merchant";
                break;
            case "user":
                tbl = "merchant_user";
                break;
            case "location": // "location-1"
                if (null == record_fk) throw new Error(`Unable to delete using partial record spec: ${record}`);
                tbl = "merchant_location";
                sql_where += ` AND ${Q("_record")} = ${q(record)}`;
                break;
            case "product": // "product-LugiCz2X"
                if (null == record_fk) throw new Error(`Unable to delete using partial record spec: ${record}`);
                tbl = "merchant_product";
                sql_where += ` AND ${Q("productID")} = ${q(record_fk)}`;
                break;
            case "productGroup": // "productGroup-gKpIJT4O"
                if (null == record_fk) throw new Error(`Unable to delete using partial record spec: ${record}`);
                tbl = "merchant_productgroup";
                sql_where += ` AND ${Q("productGroupID")} = ${q(record_fk)}`;
                break;
            default:
                throw new Error(`Unknown merchant record: ${record}`);
        }

        const sql = `DELETE FROM ${Q(tbl)} WHERE ${sql_where}`;

        //TODO
        throw new Error(`REJECTED Unsafe operation: ${sql}`);

        await $exe(sql);
    }
};

// LEGACY client
const MerchantClientDynamo = require("aws-layer/dynamo/merchantTable").MerchantClient;

Object.assign(MerchantClientDynamo, { dynamo: MerchantClientDynamo, mysql: MerchantClientMySQL });
Object.assign(MerchantClientMySQL, { dynamo: MerchantClientDynamo, mysql: MerchantClientMySQL });

Object.assign(module.exports, {
    MerchantClientMySQL,
    MerchantClientDynamo,
    MerchantClient: ["prod", "test"].includes(process.env.mode) ? MerchantClientMySQL : MerchantClientDynamo,
});
