
const mysql_client = require("pp-mysql/client");
const {
    Q, q,
    $exe,
    $tbl,
    $row,
    $one,
} = mysql_client.shorthands();

// const { Auth } = require("./Auth");

const {
    PollenError,
} = require("utils");

const {
    invalidPhoneNumber,
} = require("messages");

const {
    phone: libphone,
} = require("phone");


class UserPhone {
    static async normalize_phone(phone_raw, opts) {
        if (["+123456789", "123456789"].includes(phone_raw)) {
            // +123456789 is Apple test account that talks to test env on the live iOS App
            // pretending it's valid
            return { valid: true, phone: phone_raw };
        }

        const {
            throw_invalid = true,
            country_hint = null,
        } = opts || {};

        // https://www.npmjs.com/package/phone
        const libphone_opts = {
            country: country_hint,
            validateMobilePrefix: true,
            strictDetection: false,
        }

        // temp fix (make GP phones without a plus sign great again) (and some other phones)
        phone_raw = String(phone_raw).replace(/^44\d{10}$/, "+$&");
        phone_raw = String(phone_raw).replace(/^7\d{10}$/, "+$&");

        const r = libphone(phone_raw, libphone_opts);
        //console.log({ opts, phone_raw, libphone_opts, libphone: r });

        const {
            isValid,
            phoneNumber: phone,
            countryIso3,
            countryCode,
        } = r;

        if (!isValid || countryCode === "+1") {
            // should it really throw PollenError from such a low level?
            if (throw_invalid) throw new PollenError(invalidPhoneNumber);
            return {
                valid: false,
                phone: null,
                country_code: countryCode,
                country_iso3: countryIso3,
            }
        }

        return {
            valid: true,
            phone,
            country_code: countryCode,
            country_iso3: countryIso3,
        };
    };

    /**
    * lookup entries
    * see comments on destructuring ctx and data for info on arguments
    */
    static async query(ctx, data) {
        const {
            conn = mysql_client,
            dt: ctx_dt,     // transaction point of time
        } = ctx || {};

        const {
            user_ppid,      // (optionally) filter by this user
            //lid: phone,     // (optionally) filter by search this phone (using "lid" is considered harmful)
            phone,
            dt: data_dt,    // (optionally) effective at this point of time, default is "now()", not "undefined"! (this is not intended to be a range lookup)
            confirmed,      // (optionally) that is confirmed
            login,          // (optionally) that is login
        } = data || {};

        // data_dt has higher priority than ctx_dt
        const dt = data_dt || ctx_dt;
        const sql_dt = (dt == null) ? `NOW(6)` : conn.q(dt);

        // transition artifact
        //conn.q([phone, String(phone).replace(/^\+/g, "")])
        const phone_variants = (null == phone) ? null : [
            phone,
            String(phone).replace(/^\+?((44|7)\d{10})$/, "$1"), // forced without plus
            String(phone).replace(/^\+?((44|7)\d{10})$/, "+$1"), // forced with plus
        ];

        //const sql_phone = conn.q(phone);
        //const sql_phone = conn.q([phone, String(phone).replace(/^\+/g, "")]);

        let sql;
        const rows = await conn.$tbl(sql = `
            SELECT
                ${Q("user_ppid")},
                ${Q("phone")},
                ${Q("dt_beg")},
                ${Q("dt_end")},
                ${Q("confirmed")},
                IFNULL(${Q("login")}, 0) as login
            FROM
                ${Q("user_phone")}
            WHERE 1
                AND dt_beg <= ${sql_dt} AND dt_end > ${sql_dt}
                ${(null == user_ppid) ? `` : `AND user_ppid = ${conn.q(user_ppid)}`}
                ${(null == phone_variants) ? `` : `AND phone IN (${conn.q(phone_variants)})`}
                ${(null == confirmed) ? `` : `AND confirmed = ${confirmed ? `1` : `0`}`}
                ${(null == login) ? `` : `AND login ${login ? `= 1` : `IS NULL`}`}
            ORDER BY
                ${Q("dt_beg")}
        `);
        console.log(sql);
        return rows;
    };

    /**
    * ADD PHONE (ppid must exist)
    * returns nothing on success
    */
    static async add(ctx, data) {
        const {
            conn = mysql_client,
            dt: ctx_dt,     // transaction point of time
        } = ctx || {};

        const {
            user_ppid,
            phone,
        } = data;

        await conn.$trx({ nest: true }, async (conn) => {
            const q = conn.q.bind(conn);
            //await conn.$exe(`SET @dt = NOW(6)`);
            const dt = await conn.$one(`SELECT @dt := ${ctx_dt == null ? `NOW(6)` : conn.q(ctx_dt)}`);

            //const user_ppid_exists = await conn.$exe(`SELECT 1 FROM user WHERE ppid = ${q(user_ppid)}`);
            //await conn.$exe(`if (!@user_ppid_exists) signal_rollback "This should be constrainted with a foreign key linked to user."`);
            await conn.$exe(`
                INSERT IGNORE INTO user_phone
                SET user_ppid = ${q(user_ppid)}, phone = ${q(phone)}, dt_beg = @dt, confirmed = 0, login = NULL
            `);
            await conn.$exe(`
                UPDATE user_phone
                FOR PORTION OF link FROM @dt TO DEFAULT(dt_end)
                SET confirmed = 0
                WHERE 1
                    AND dt_beg <= @dt AND dt_end > @dt
                    AND user_ppid = ${q(user_ppid)}
                    AND phone = ${q(phone)}
                    AND confirmed = 0
            `);
        });
    };

    /**
    * CONFIRM PHONE AND TRY TO SET IT AS LOGIN (ppid must exist)
    * TODO returns true if a phone was set as login, false otherwise
    */
    static async confirm_set(ctx, data) {
        const {
            conn = mysql_client,
            dt: ctx_dt,     // transaction point of time
        } = ctx || {};

        let { user_ppid } = data;
        const { phone } = data;

        if (null == user_ppid) throw new Error("Invalid user_ppid.");

        return await conn.$trx({ nest: true }, async (conn) => {
            const q = conn.q.bind(conn);
            const dt = await conn.$one(`SELECT @dt := ${ctx_dt == null ? `NOW(6)` : conn.q(ctx_dt)}`);
            //dt = await conn.$one(`SELECT @dt := ${dt == null ? `NOW(6)` : q(dt)}`);
            //const sql_dt = q(dt);

            // search for any user that has supplied phone set as login
            // null for user_ppid works here as expected
            const user_ppid_other = await conn.$one(`
                SELECT user_ppid FROM user_phone WHERE dt_beg <= @dt AND dt_end > @dt AND user_ppid != ${q(user_ppid)} AND phone = ${q(phone)} AND login
            `);

            //let user_ppid_new = false;

            //if (null == user_ppid) {
            //    // "registration" mode
            //    if (user_ppid_other) throw new Error("Sorry, but this phone may not be used for registration. Please, contact support.");
            //
            //    //(allocate ppid, set @user_ppid = new ppid);
            //    ({ user_ppid }) = await Auth.mk_user_ppid({ conn, dt });
            //    user_ppid_new = true;
            //}

            await conn.$exe(`
                INSERT IGNORE INTO user_phone
                SET user_ppid = ${q(user_ppid)}, phone = ${q(phone)}, dt_beg = @dt, confirmed = 1, login = NULL
            `);

            await conn.$exe(`
                UPDATE user_phone
                FOR PORTION OF link FROM @dt TO DEFAULT(dt_end)
                SET confirmed = 1, login = ${user_ppid_other ? `NULL` : `1`} /* IF(@user_ppid_other, null, 1) */
                WHERE 1
                    AND dt_beg <= @dt AND dt_end > @dt
                    AND user_ppid = ${q(user_ppid)}
                    AND phone = ${q(phone)}
            `);

            // -- if (@user_ppid_other) signal_commit 'The phone is confirmed, but you can not use it for login, sorry. Please, contact support.';
            return user_ppid_other ? false : true;
        });
    };

    /**
    * SET LOGIN PHONE
    * returns nothing on success
    * throws on failure
    */
    static async login_set(ctx, data) {
        const {
            conn = mysql_client,
            dt: ctx_dt,     // transaction point of time
        } = ctx || {};

        const { user_ppid, phone } = data;
        await mysql_client.$trx({ nest: true }, async (conn) => {
            const q = conn.q.bind(conn);
            const dt = await conn.$one(`SELECT @dt := ${ctx_dt == null ? `NOW(6)` : conn.q(ctx_dt)}`);
            //await conn.$exe(`SET @dt = NOW(6)`);

            await conn.$exe(`
                UPDATE user_phone
                FOR PORTION OF link FROM @dt TO DEFAULT(dt_end)
                SET login = 1
                WHERE 1
                    AND dt_beg <= @dt AND dt_end > @dt
                    AND user_ppid = ${q(user_ppid)}
                    AND phone = ${q(phone)}
                `);
        });
    };

    /**
    * UNSET LOGIN PHONE
    * returns nothing on success
    * throws on failure
    */
    static async login_uns(ctx, data) {
        const {
            conn = mysql_client,
            dt: ctx_dt,     // transaction point of time
        } = ctx || {};

        const {
            user_ppid,
            phone,
        } = data;

        await mysql_client.$trx({ nest: true }, async (conn) => {
            const q = conn.q.bind(conn);
            const dt = await conn.$one(`SELECT @dt := ${ctx_dt == null ? `NOW(6)` : conn.q(ctx_dt)}`);
            //await conn.$exe(`SET @dt = NOW(6)`);

            // "is last LOGIN phone?"
            const is_last = await conn.$one(`
                SELECT 0 = COUNT(*) FROM user_phone WHERE dt_beg <= @dt AND dt_end > @dt AND user_ppid = ${q(user_ppid)} AND phone != ${q(phone)} AND login
            `);
            if (is_last) {
                throw new Error("You can not do this: there should be at least one phone used for sign into your account.");
            }

            await conn.$exe(`
                UPDATE user_phone
                FOR PORTION OF link FROM @dt TO DEFAULT(dt_end)
                SET login = null
                WHERE 1
                    AND dt_beg <= @dt AND dt_end > @dt
                    AND user_ppid = ${q(user_ppid)}
                    AND phone = ${q(phone)}
            `);
            /* the previous operation does nothing for not phone not being added earlier; should it throw? */
        });
    };

    /**
    * UNLINK PHONE
    */
    static async unlink(ctx, data) {
        const {
            conn = mysql_client,
            dt: ctx_dt,     // transaction point of time
        } = ctx || {};

        const {
            phone,
        } = data;

        await mysql_client.$trx({ nest: true }, async (conn) => {
            const q = conn.q.bind(conn);
            const dt = await conn.$one(`SELECT @dt := ${ctx_dt == null ? `NOW(6)` : conn.q(ctx_dt)}`);
            //await conn.$exe(`SET @dt = NOW(6)`);

            // "is last phone AT ALL?"
            const is_last = await conn.$one(`
                SELECT 0 = COUNT(*) FROM user_phone WHERE dt_beg <= @dt AND dt_end > @dt AND user_ppid = ${q(user_ppid)} AND phone != ${q(phone)}
            `);
            if (is_last) throw new Error("You can not unlink the last phone from your account.");
            await conn.$exe(`
                UPDATE user_phone
                SET dt_end = @dt
                WHERE 1
                    AN dt_beg <= @dt AND dt_end > @dt
                    AND user_ppid = ${q(user_ppid)}
                    AND phone = ${q(phone)}
            `);
            /* the previous operation does nothing for phone not being added earlier; should it throw? */
        });
    };

    /**
    * EDIT PHONE
    */
    static async edit(data) {
        const {
            conn = mysql_client,
            dt: ctx_dt,     // transaction point of time
        } = ctx || {};

        const {
            user_ppid,
            phone_old,
            phone_new,
        } = data;

        await mysql_client.$trx({ nest: true }, async (conn) => {
            const q = conn.q.bind(conn);
            const dt = await conn.$one(`SELECT @dt := ${ctx_dt == null ? `NOW(6)` : conn.q(ctx_dt)}`);
            //await conn.$exe(`SET @dt = NOW(6)`);

            await conn.$exe(`
                UPDATE user_phone
                SET dt_end = @dt
                WHERE 1
                    AND dt_beg <= @dt AND dt_end > @dt
                    AND user_ppid = ${q(user_ppid)}
                    AND phone = ${q(phone_old)}
                    AND confirmed = 0
            `);
            await conn.$exe(`
                INSERT IGNORE INTO user_phone
                SET user_ppid = ${q(user_ppid)}, phone = ${q(phone_new)}, dt_beg = @dt, confirmed = 0, login = null
            `);
            await conn.$exe(`
                UPDATE user_phone
                FOR PORTION OF link FROM @dt TO DEFAULT(dt_end)
                SET confirmed = 0
                WHERE 1
                    AND dt_beg <= @dt AND dt_end > @dt
                    AND user_ppid = ${q(user_ppid)}
                    AND phone = ${q(phone_new)}
                    AND confirmed = 0
            `);
        });
    };
};

Object.assign(module.exports, {
    UserPhone,
});
