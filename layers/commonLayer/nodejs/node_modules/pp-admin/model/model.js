const {Q, q, qlike, $exe, $tbl, $row } = require('pp-mysql/client').shorthands();

/// Functions for filter list of objects
const FUNC = {
    EQ: 'eq', ///< Field (EQ)ual Value
    NOT: 'not', ///< Field (NOT) Equal Value
    LT: 'lt', ///< Field (L)ess (T)hen Value
    LTE: 'lte', ///< Field (L)ess (T)hen or (E)qual Value
    GT: 'gt', ///< Field (G)reater (T)hen Value
    GTE: 'gte', ///< Field (G)reater (T)hen or (E)qual Value
    LIKE: 'like', ///< Field (LIKE) Value
    HAS: 'has', ///< Field (HAS) Value inside string
    IHAS: 'ihas', ///< Field (I)ndepent case (HAS) Value inside string
};

/// Signs for functions
const SIGN = {
    [FUNC.EQ]: '=',
    [FUNC.NOT]: '!=',
    [FUNC.LT]: '<',
    [FUNC.LTE]: '<=',
    [FUNC.GT]: '>',
    [FUNC.GTE]: '>=',
    [FUNC.LIKE]: true,// Not applicable as sign function
    [FUNC.HAS]: true,// Not applicable as sign function
    [FUNC.IHAS]: true,// Not applicable as sign function
}

/// Search options for fields
const SEARCH = {
    WEQ: 'weq',///< Weight of search word (EQ)ual field
    WIEQ: 'wieq',///< Weight of search word (I)ndepend case (EQ)ual field
    WHAS: 'whas',///< Weight of field (HAS) search word inside
    WIHAS: 'wihas',///< Weight of field (I)ndepend case (HAS) search word inside
    CONCAT: 'concat',///< Flag, that field is GROUP_CONCAT of string by spaces with begin and end space
};

/// Special values for DB field
const FIELD = {
    MODE: 'mode',///< Field mode, see MODE_..., by default MODE_DB
    REQ: 'req',///< Array of required API fields for construct this field
    SELECT: 'select',///< SQL for select calc/patch/join fields
    UPDATE: 'update',///< SQL for update field (with VALUE_PLACE inside for place real value from request)
    VALUE_PLACE: 'VALUE',///< In this place real value for UPDATE will be placed
    DBFIELD: 'dbfield',///< DB field, by default API field
    ONNULL: 'onnull',///< Value for NULL in field, by default empty string
    CTE: 'cte',///< CTE SQL for field, may be for MODE_JOIN
    JOIN: 'join',///< JOIN SQL for field, required for MODE_JOIN
    READONLY: 'readonly',///< Flag for readonly fields

// Variants of field mode
    MODE_DB: 'DB',///< Simple DB field mapping
    MODE_JOIN: 'JOIN',///< JOINed readonly field
    MODE_CALC: 'CALC',///< Calculated by SQL virtual field
    MODE_PATCH: 'PATCH',///< Patched on read by SQL real read/write field
}

const isNumber = (v) => ("number" === typeof v);

const isString = (v) => ("string" === typeof v);

/// Check type can be converted to string
const isStringable = (v) => ["string", "number", "bigint"].includes(typeof v);

const isArray = (v) => Array.isArray(v);

const isEmptyArray = (v) => (v.length === 0);

const isObject = (v) => ("object" === typeof v);

const isEmptyObject = (v) => isEmptyArray(Object.keys(v));

class Model {
    static ID = 'id';///< API field for ID
    static SID = 'sid';///< API field for String ID
    static MAXLEN = 1000000000;///< Max length for LIMIT
    static MAXORDERS = 4;///< Max count of ORDER BY

    static table = '';///< DB table name, must be overwritten in children

    /// { API field => { field options, see FIELD }, ... }, must be overwritten in children
    static api2db = {};

    /// Search options { API field => { SEARCH...: ..., ...}, ... }, must be overwritten in children
    static search = {};

    // Add related fields to get, if need
    // static patchGet(get) { ...; return get; }

    // Add related fields to set, if need
    // static patchSet(set) { ...; return set; }

    // Add some special and, for example, exclude marking as deleted
    // static patchAnds(ands) { ...; return ands; }

    // Some magic patch row, specific for model
    // static patchRow(row) { ...; return row; }
    static patchRow(row) {
        Object.keys(row).forEach((apifield) => {
            if (null === row[apifield]) delete row[apifield];
        });
        return row;
    }

    // Some magic patch rows, specific for model
    // static patchRows(rows) { ...; return rows; }
    static patchRows(rows) {
        rows.forEach((row) => Model.patchRow(row));
        return rows;
    }

    /// Insert one row
    static async add(set, get) {

    // Check validity and add related fields of input parameters
        this.checkSet(set); this.checkGet(get);

    // Make INSERT sql
        const sql = this.sqlInsert(set);

    // Wait execute
        const r = await $exe(sql);

    // Return row by ID
        return this.row(r[0].insertId, get);
    };

    /// Get one row by ID
    static async row(id, get) {

    // Check validity and add related fields of input parameters
        this.checkID(id); this.checkGet(get);

    // Make SELECT sql for row
        const sql =
            this.sqlCTEs(get) +
            this.sqlSelect(get) +
            this.sqlJoins(get) +
            this.sqlWhere(this.andID(id));
        //console.log(sql);//DEBUG

    // Return result of select
        const row = await $row(sql);
        if ((row) && (this.patchRow)) return this.patchRow(row);
        else return row;
    };

    /// Set one row by ID
    static async upd(id, set, get) {

    // Check validity and add related fields of input parameters
        this.checkID(id); this.checkSet(set); this.checkGet(get);

    // Make UPDATE sql
        const sql = this.sqlUpdate(set) + this.sqlWhere(this.andID(id)) +
            ' LIMIT 1' // condom for update
        ;

    // Wait update
        await $exe(sql);

    // Return row by ID
        return this.row(id, get);
    };

    /// Add/set one row by ID
    static async addupd(set, get) {

    // Check validity and add related fields of input parameters
        this.checkSet(set); this.checkGet(get);

    // Make INSERT ... UPDATE sql
        const sql = this.sqlInsertUpdate(set);

    // Wait execute
        const r = await $exe(sql);

    // Extract ID from result or from set
        const id = r.insertId ?? set[this.ID];

    // Return row by ID
        return this.row(id, get);
    };

    /// Delete one row by ID
    static async del(id) {

    // Check validity of input parameters
        this.checkID(id);

    // Make DELETE sql
        const sql = this.sqlDelete() + this.sqlWhere(this.andID(id)) +
            ' LIMIT 1' // condom for delete
        ;

    // Wait delete
        await $exe(sql);
        return true;
    };

    /// Get many rows by filter and with orders
    static async tbl(get, and = [], order = [], ofs = 0, len = this.MAXLEN) {

    // Check validity and add related fields of input parameters
        this.checkAnd(and); this.checkOrder(order); this.checkOfs(ofs); this.checkLen(len);
        this.checkGet(get, and, order);

        // Make SELECT sql with WHERE/ORDER/LIMIT
        const sql =
            this.sqlCTEs(get, and, order) +
            this.sqlSelect(get) +
            this.sqlJoins(get, and, order) +
            this.sqlWhere(and) +
            this.sqlOrderBy(order) +
            this.sqlLimit(ofs, len)
        ;
        //console.log(sql);//DEBUG

    // Return result of select
        const tbl = await $tbl(sql);
        return { body: (tbl) && (this.patchRows) ? this.patchRows(tbl) : tbl };
    };

    /// Make INSERT as string for SQL
    static sqlInsert(set) {
        return `INSERT INTO ${Q(this.table)} SET ${this.sqlSet(set)}`;
    };

    /// Make SELECT as string for SQL
    static sqlSelect(get) {
        const selects = [];
        get.forEach((apifield) => {
            const fieldobj = this.fieldObj(apifield);
            const onnull = fieldobj[FIELD.ONNULL];
        // Use predefined value for NULL in DB, is in options
            if (undefined !== onnull) selects.push(`IFNULL(${this.QSelect(apifield)},${q(onnull)}) AS ${Q(apifield)}`);
        // Else return field AS IS
            else selects.push(`${this.QSelect(apifield)} AS ${Q(apifield)}`)
        });
        return `SELECT ${selects.join(',')} FROM ${Q(this.table)}`;
    };

    /// Generate all CTEs as string for SQL
    static sqlCTEs(get, and = [], order = []) {
        const ctes = [];

        // Add CTE by API field
        const addCTEIfNeed = (apifield, recursive = true) => {
            const fieldobj = this.fieldObj(apifield);

            if (recursive) {
                const req = fieldobj[FIELD.REQ] ?? [];
                req.forEach((reqfield) => addCTEIfNeed(reqfield, false));
            }

            if (FIELD.MODE_JOIN === fieldobj[FIELD.MODE]) {
                const cte = fieldobj[FIELD.CTE];
                if (!cte) return;// CTE may be absent
                let scte;
                if (cte instanceof Function) fieldobj[FIELD.CTE] = scte = cte();
                else if (!isString(cte)) throw new Error(`Non-string in '${FIELD.CTE}'`);
                else if (/^[a-zA-Z0-9_]+$/.test(cte)) {// function name for make CTE SQL
                    if ((!this[cte]) || (!(this[cte] instanceof Function))) throw new Error(`Unknown function '${cte}'`);
                    fieldobj[FIELD.CTE] = scte = this[cte]();
                }
                else scte = cte;// already CTE SQL
                if (('' !== scte) && (!ctes.includes(scte))) ctes.push(scte);
            }
        };

    // Add CTEs to list by get, and, order API fields
        get.forEach((apifield) => addCTEIfNeed(apifield));
        and.forEach((oneand) => {
            if (isArray(oneand)) oneand.forEach((oneor) => addCTEIfNeed(oneor.fld));
            else addCTEIfNeed(oneand.fld);
        });
        order.forEach((iorder) => addCTEIfNeed(String(iorder[0])));
        if (isEmptyArray(ctes)) return '';
        return `WITH ${ctes.join(',')} `;
    };

    /// Generate all JOIN as string for SQL
    static sqlJoins(get, and = [], order = []) {
        const joins = [];

    // Add JOIN by API field
        const addJoinIfNeed = (apifield, recursive = true) => {
            const fieldobj = this.fieldObj(apifield);

            if (recursive) {
                const req = fieldobj[FIELD.REQ] ?? [];
                req.forEach((reqfield) => addJoinIfNeed(reqfield, false));
            }
            if (FIELD.MODE_JOIN === fieldobj[FIELD.MODE]) {
                const join = fieldobj[FIELD.JOIN];
                let sjoin;
                if (join instanceof Function) fieldobj[FIELD.JOIN] = sjoin = join();
                else if (!isString(join)) throw new Error(`Non-string in '${FIELD.JOIN}'`);
                else if (/^[a-zA-Z0-9_]+$/.test(join)) {// function name for make JOIN SQL
                    if ((!this[join]) || (!(this[join] instanceof Function))) throw new Error(`Unknown function '${join}'`);
                    fieldobj[FIELD.JOIN] = sjoin = this[join]();
                }
                else sjoin = join;// already JOIN SQL
                if (!joins.includes(sjoin)) joins.push(sjoin);
            }
        };

    // Add JOINs to list by get, and, order API fields
        get.forEach((apifield) => addJoinIfNeed(apifield));
        and.forEach((oneand) => {
            if (isArray(oneand)) oneand.forEach((oneor) => addJoinIfNeed(oneor.fld));
            else addJoinIfNeed(oneand.fld);
        });
        order.forEach((iorder) => addJoinIfNeed(String(iorder[0])));
        if (isEmptyArray(joins)) return '';
        return ` ${joins.join(' ')} `;
    };

    /// Make UPDATE as string for SQL
    static sqlUpdate(set) {
        if (set[this.ID]) throw new Error(`Can't update '${this.ID}'`);
        return `UPDATE ${Q(this.table)} SET ${this.sqlSet(set)}`;
    };

    /// Make INSERT ... UPDATE as string for SQL
    static sqlInsertUpdate(set) {
    // Deep copy set fields to update
        const update = { ...set};

    // Don't update ID on duplicate keys
        if (update[this.ID]) delete update[this.ID];

    // If no updates, return insert only
        if (isEmptyArray(update)) return this.sqlInsert(set);

    // Else return INSERT ... UPDATE
        return `INSERT INTO ${Q(this.table)} SET ${this.sqlSet(set)} ON DUPLICATE KEY UPDATE ${this.sqlSet(update)}`;
    };

    /// Make DELETE as string for SQL
    static sqlDelete() {
        return `DELETE FROM ${Q(this.table)}`;
    };

    /// Make SET values as string for SQL
    static sqlSet(set) {
        const sets = [];
        Object.keys(set).forEach((apifield) => {
            const fieldobj = this.fieldObj(apifield);
            const mode = fieldobj[FIELD.MODE] ?? FIELD.MODE_DB;
            if ((![FIELD.MODE_DB, FIELD.MODE_PATCH].includes(mode)) ||
                (fieldobj[FIELD.READONLY]) ||
                (this.ID === apifield) || (this.SID === apifield)// block overwrite IDs
            ) throw new Error(`Can't set readonly '${apifield}'`);
            const dbfield = fieldobj[FIELD.DBFIELD] ?? apifield;

        // By default set value
            let qvalue = q(set[apifield]);

        // If exists, apply special SQL for value
            if (fieldobj[FIELD.UPDATE]) qvalue = fieldobj[FIELD.UPDATE].replaceAll(FIELD.VALUE_PLACE, qvalue);

        // First part is real DB field
            const parts = dbfield.split('.');
            const Qdbfield = Q(parts.shift());
            if (isEmptyArray(parts)) sets.push(`${Qdbfield}=${qvalue}`);
            else {
            // Other parts is JSON object fields
                sets.push(`${Qdbfield}=JSON_SET(${Qdbfield}, "$.${parts.join('.')}", ${qvalue})`);
            }
        });
        return ` ${sets.join(',')}`;
    };

    /// Make WHERE/HAVING as string for SQL
    static sqlWhere(and) {
        const where_ands = [];
        const having_ands = [];

        const isHavingField = (apifield) => {
            const fieldobj = this.fieldObj(apifield);
            const mode = fieldobj[FIELD.MODE] ?? FIELD.MODE_DB;
            return [FIELD.MODE_CALC, FIELD.MODE_PATCH].includes(mode);
        };

        and.forEach((oneand) => {
            let having = false;
            let sql;
            if (isArray(oneand)) {
                const ors = [];
                oneand.forEach((oneor) => {
                    ors.push(this.sqlFunc(oneor));
                    if (isHavingField(oneor.fld)) having = true;
                });
                sql = `(${ors.join(')OR(')})`;
            }
            else {
                sql = this.sqlFunc(oneand);
                if (isHavingField(oneand.fld)) having = true;
            }
            if (!having) where_ands.push(sql);
            else having_ands.push(sql);
        });

    // Add specific ands, for example, exclude of marked as deleted
        if (this.patchAnds) this.patchAnds(where_ands);

    // Return WHERE and HAVING
        return (isEmptyArray(where_ands) ? '' : ` WHERE (${where_ands.join(')AND(')})`) +
            (isEmptyArray(having_ands) ? '' : ` HAVING (${having_ands.join(')AND(')})`);
    };

    /// Make SQL for one condition
    static sqlFunc(funcobj) {
        const { fld: apifield, func = FUNC.EQ, val, arr } = funcobj;
        let v = val ?? arr;
        const Qfield = this.QWhere(apifield);
        if (isArray(Qfield)) return this.sqlFuncArrField(apifield, func, Qfield, v);
        let tv = typeof v;
        if ("object" === tv) {
            if (v instanceof Date) {
            // Special quote for date
                v = this.qdate(v);
            // Pseudotype for use in check value type
                tv = "date";
            }
            else if (isArray(v)) {
                const av = [];
                v.forEach((iv) => {
                    if (isStringable(iv)) av.push(q(iv));
                    else if ((isObject(iv)) && (iv instanceof Date)) av.push(`${this.qdate(iv)}`);
                    else throw new Error(`Unsupported in array value type '${typeof iv}'`);
                });
                if (FUNC.EQ === func) return `${Qfield} IN (${av.join(',')})`;
                else if (FUNC.NOT === func) return `${Qfield} NOT IN (${av.join(',')})`;
                else throw new Error(`Invalid function '${func}' for array value`);
            }
            else throw new Error(`Unsupported value type '${tv}'`);
        }

        const fortext = `for function '${func}'`;
    // One code for all sign functions
        const sign = SIGN[func];
        if ((sign) && (true !== sign)) {
            this.checkTypeComparable(tv, fortext);
            if ("date" === tv) return `${Qfield}${sign}${v}`;// date already escaped
            else return `${Qfield}${sign}${q(v)}`;
        }
    // Other not sign functions
        else {
            this.checkTypeStringable(tv, fortext);
            v = String(v);
            switch (func) {
                case FUNC.LIKE:
                    return `${Qfield} LIKE ${q(qlike(v))}`;
                case FUNC.HAS:
                    return `IF(LOCATE(${q(v)},${Qfield})>0,1,0)`;
                case FUNC.IHAS:
                    return `IF(LOCATE(${q(v.toLowerCase())},LOWER(${Qfield}))>0,1,0)`;
                default:
                    throw new Error(`Unknown not sign function '${func}'`);
            }
        }
    };

    /// Make SQL for one condition for array field
    static sqlFuncArrField(apifield, func, Qfields, v) {
        if (FUNC.EQ !== func) throw new Error(`Unsupported function '${func}' for array field ${apifield}`);
        const ors = [];
        if (!isArray(v)) v = [ v ];
        v.forEach((iv) => {
            if (!isString(iv)) throw new Error(`Value for array field ${apifield} must be stringified JSON array`);
            try {
                iv = JSON.parse(iv);
            }
            catch (err) {
                throw new Error(`Can't parse JSON from value ${apifield}`);
            }
            if (!isArray(iv)) throw new Error(`Value for array field ${apifield} must be stringified JSON array`);
            if (iv.length !== Qfields.length) throw new Error(`Invalid count of values in JSON array for array field ${apifield}`);
            const ands = [];
            Qfields.forEach((Qfield, i) => ands.push(`${Qfield}=${q(iv[i])}`));
            ors.push(`(${ands.join(')AND(')})`);
        });
        return `(${ors.join(')OR(')})`;
    }

    /// Check type can be compared by signs >,<,=
    static checkTypeComparable(tv, fortext) {
        this.checkTypeOfV(tv, ["bigint", "number", "string", "date"], fortext);
    };

    /// Check type can be converted to string
    static checkTypeStringable(tv, fortext) {
        this.checkTypeOfV(tv, ["string", "number", "bigint"], fortext);
    };

    /// Check type of value one of array of types
    static checkTypeOfV(tv, typeofs, fortext) {
        if (!typeofs.includes(tv)) {
            throw new Error(`Invalid value type '${tv}' ${fortext}`)
        }
    };

    /// Make ORDER BY as string
    static sqlOrderBy(order) {
        if (isEmptyArray(order)) order = [ [ this.ID, 'ASC'] ];
        const orderbys = [];
        order.forEach((iorder) => {
            const apifield = String(iorder[0]);
            const dir = (iorder[1] ?? 'ASC').toUpperCase();
            orderbys.push(`${this.QWhere(apifield)} ${dir}`);
        });
        return ` ORDER BY ${orderbys.join(',')}`;
    };

    /// Make LIMIT as string
    static sqlLimit(ofs, len) {
        const { MAXLEN } = this;
        if ("number" !== typeof ofs) ofs = parseInt(ofs);
        if ("number" !== typeof len) len = parseInt(len);
        if ((0 === ofs) && (len >= MAXLEN)) return '';
        return ` LIMIT ${ofs},${len}`;
    };

    /// Make parameter and for select by ID only
    static andID(id) {
        return [{ fld: this.ID, val: id, func: FUNC.EQ }];
    };

    /// Escape date for SQL
    static qdate(v) {
    // trying to be timezone-agnostic a well as not losing precision
        return `FROM_UNIXTIME(CAST(${q(Number(v))} AS DECIMAL(20, 3))/1000))`;
    };

    /// Escape DB field for SELECT
    static QSelect(apifield) {
        return this.Q(apifield, true);
    };

    /// Escape DB field for WHERE/HAVING
    static QWhere(apifield) {
        return this.Q(apifield, false);
    };

    /// Escape DB field for SQL
    static Q(apifield, isSelect) {
    // Check API field exists
        const fieldobj = this.fieldObj(apifield);
        const mode = fieldobj[FIELD.MODE] ?? FIELD.MODE_DB;
        const dbfield = fieldobj[FIELD.DBFIELD] ?? apifield;

    // Some not usual field
        if (FIELD.MODE_DB !== mode) {

            const fieldSelect = (fieldobj, def) => {
                const select = fieldobj[FIELD.SELECT] ?? (null === fieldobj[FIELD.SELECT] ? null : def);
                if (undefined === select) throw new Error(`No SELECT for field '${apifield}'`);
                if (select instanceof Function) return select();
                return select;
            };

        // Different logic for each field mode
            switch (mode) {
            // Readonly JOINed field, return API field
                case FIELD.MODE_JOIN: {
                    const join = fieldobj[FIELD.JOIN];
                    if (!join) throw new Error(`No JOIN SQL for field '${apifield}'`)
                    return fieldSelect(fieldobj, Q(apifield));
                }

            // Calculated virtual field
                case FIELD.MODE_CALC: {
                    if (!isSelect) return Q(apifield);
                    return fieldSelect(fieldobj);
                }

            // Patched real field
                case FIELD.MODE_PATCH: {
                    if (!isSelect) break;
                    return fieldSelect(fieldobj);
                }

                default: throw new Error(`Unknown mode for field '${apifield}'`);
            }
        }

    // Array of dbfield return as string with JSON array values inside
        if (isArray(dbfield)) {
            const Qdbfields = [];
            dbfield.forEach((idbfield) => {
                if (isArray(idbfield)) {
                    const path = [];
                    idbfield.forEach((ipath) => path.push(Q(ipath)));
                    Qdbfields.push(path.join('.'));
                }
                else Qdbfields.push(`${Q(this.table)}.${Q(idbfield)}`)
            });
            if (isSelect) return `JSON_ARRAY(${Qdbfields.join(',')})`;
            return Qdbfields;
        }

    // Explode by .
        const parts = dbfield.split('.');

    // First part is real DB field
        const Qdbfield = `${Q(this.table)}.${Q(parts.shift())}`;
        if (isEmptyArray(parts)) return Qdbfield;

    // Other parts is JSON object fields
        return `JSON_UNQUOTE(JSON_EXTRACT(${Qdbfield}, "$.${parts.join('.')}"))`;
    };

    /// Check validity of id parameter
    static checkID(id) {
        if (!id) throw new Error(`Parameter '${this.ID}' is required`);
        this.checkTypeStringable(typeof id, `for field '${this.ID}'`);
    }

    /// Check validity of get parameter
    static checkGet(get, and = [], order = []) {
    // Check type of get
        if (!get) throw new Error("Parameter 'get' is required");
        if (!isArray(get)) throw new Error("Parameter 'get' must be array");

    // Check all fields for existing
        get.forEach((apifield) => {
            this.fieldObj(apifield, "in parameter 'get'");
        });

    // For empty get return all available fields
        if (isEmptyArray(get)) Object.keys(this.api2db).forEach((apifield) => {
            this.fieldObj(apifield, "in 'api2db'");// Check field object validity
            get.push(apifield)
        });

    // Always return ID
        if (!get.includes(this.ID)) {
            this.fieldObj(this.ID, `in '${this.ID}'`);// Check field object validity
            get.push(this.ID);
        }

    // Add related get fields
        if (this.patchGet) {
            const l = get.length;
            this.patchGet(get);
            for (let i = l; i < get.length; ++i) {// Check field object validity
                this.fieldObj(get[i], `in 'patchGet'`);
            }
        }

    // Check and field and add it to get, if calc field
        const addIfNeed = (apifield, intext) => {
            if (!get.includes(apifield)) {
                const fieldobj = this.fieldObj(apifield, intext);// Check field object validity
            // For compare or order by calc fields, it must be in get
                if (FIELD.MODE_CALC === fieldobj[FIELD.MODE]) get.push(apifield);
            }
        };

    // Check all fields in and for add calc fields to get
        and.forEach((oneand) => {
            if (isArray(oneand)) {
                oneand.forEach((oneor) => addIfNeed(oneor.fld, "in 'and' ors"));
            }
            else addIfNeed(oneand.fld, "in 'and'");
        });

    // Check all fields in order for add calc fields to get
        order.forEach((iorder) => addIfNeed(String(iorder[0]), "in 'order'"));
    };

    /// Check validity of set parameter
    static checkSet(set) {

    // Check type of set
        if (!set) throw new Error("Parameter 'set' is required");
        if (!isObject(set)) throw new Error("Parameter 'set' must be object");

    // Check all fields for existing
        Object.keys(set).forEach((apifield) => {
            const fieldobj = this.fieldObj(apifield, "in parameter 'set'");
            const mode = fieldobj[FIELD.MODE] ?? FIELD.MODE_DB;
            if (![FIELD.MODE_DB, FIELD.MODE_PATCH].includes(mode)) {
                throw new Error(`Try set readonly field '${apifield}' in parameter 'set'`)
            }
        });

    // Add related set fields
        if (this.patchSet) this.patchSet(set);

    // Check set length
        if (isEmptyObject(set)) throw new Error("Parameter 'set' can't be empty object");
    };

    /// Check validity of and parameter
    static checkAnd(and) {
        if (!isArray(and)) throw new Error("Parameter 'and' must be array");
        and.forEach((oneand) => {
            if (isArray(oneand)) {
                if (isEmptyArray(oneand)) throw new Error("Array of ORs can't be empty");
                oneand.forEach((oneor) => this.checkFunc(oneor));
            }
            else this.checkFunc(oneand);
        });
    };

    /// Check one condition object
    static checkFunc(funcobj) {
        if (!isObject(funcobj)) throw new Error(`Unsupported type for function in parameter 'and'`);
        const {fld: apifield, val, arr, func = FUNC.EQ } = funcobj;
        this.fieldObj(apifield, "in parameter 'and'");
        if ("string" !== typeof func) throw new Error(`Function must be string for field '${apifield}' in parameter 'and'`);
        if (!SIGN[func]) throw new Error(`Unknown function '${func}' for field '${apifield}' in parameter 'and'`);
        if (undefined === (val ?? arr)) throw new Error(`'val' or 'arr' is required for field '${apifield}' in parameter 'and'`);
        if ((undefined !== val) && (isArray(val))) throw new Error(`'val' can't be array for field '${apifield}' in parameter 'and'`);
        if (undefined !== arr) {
            if (!isArray(arr)) throw new Error(`'arr' must be array for field '${apifield}' in parameter 'and'`);
            if (isEmptyArray(arr)) throw new Error(`'arr' can't be empty for field '${apifield}' in parameter 'and'`);
        }
    };

    /// Check validity of order parameter
    static checkOrder(order) {
        if (!isArray(order)) throw new Error("Parameter 'order' must be array");
        if (order.length > this.MAXORDERS) throw new Error(`Parameter 'order' must be not greater ${this.MAXORDERS}`);
        order.forEach((iorder) => {
            if (!isArray(iorder)) throw new Error("Parameter 'order' must be array or arrays");
            if (iorder.length > 2) throw new Error(`Greater 2 items in parameter 'order'`);
            if (!isString(iorder[0])) throw new Error(`Field name must be string in parameter 'order'`);
            this.fieldObj(iorder[0], "in parameter 'order'");
            const dir = iorder.length > 1 ? String(iorder[1]).toUpperCase() : 'ASC';
            if (!['ASC', 'DESC'].includes(dir)) {
                throw new Error(`Unknown order direction '${dir}' in parameter 'order'`);
            }
        });
    };

    /// Get field description object
    static fieldObj(apifield, intext) {
        const fieldobj = this.api2db[apifield];
        if ((!fieldobj) || (!isObject(fieldobj))) throw new Error(`Unknown field '${apifield}' ${intext}`);
        return fieldobj;
    };

    /// Check validity of ofs parameter
    static checkOfs(ofs) {
        if ((!ofs) && (0 !== ofs)) throw new Error(`Invalid value of parameter 'ofs'`);
        if (!/^\d+$/.test(String(ofs))) throw new Error(`Parameter 'ofs' must be not negative integer`);
        if (parseInt(ofs) >= this.MAXLEN) throw new Error(`Parameter 'ofs' can't be greater or equal ${this.MAXLEN}`);
    };

    /// Check validity of len parameter
    static checkLen(len) {
        if (!len) throw new Error(`Invalid value of parameter 'len'`);
        if (!/^[1-9]\d*$/.test(String(len))) throw new Error(`Parameter 'len' must be positive integer`);
        if (parseInt(len) > this.MAXLEN) throw new Error(`Parameter 'len' can't be greater ${this.MAXLEN}`);
    };

    /// Add related fields to get, if need
    static patchGetByPools(get, pools) {
        const inget = [...get];
        pools.forEach((pool) => {
            let exists = false;
            pool.forEach((field) => {
                if (inget.includes(field)) exists = true;
            });
            if (exists) {
                pool.forEach((field) => {
                    if (!inget.includes(field)) get.push(field);
                });
            }
        });
        return get;
    };
}

module.exports = {
    isNumber, isString, isStringable, isArray, isEmptyArray, isObject, isEmptyObject,
    FUNC, SEARCH, FIELD,
    Model,
};
