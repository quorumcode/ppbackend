const { Q } = require('pp-mysql/client').shorthands();
const { isArray } = require('./model');
const { UserBase } = require('./userbase');
const { LoanBase } = require('./loanbase');

/// User
class User extends UserBase {
    /// Get many user rows by filter and with orders
    static async tbl(get, and = [], order = [], ofs = 0, len = this.MAXLEN) {
        if ((isArray(order)) && (!order.length)) order = [ [this.LOANS.HAVE_OUTSTANDING, 'DESC'], [this.LOANS.LATEST_DT, 'DESC']];
        return super.tbl(get, and, order, ofs, len);
    };

    /// Delete one user by ID
    static async del(id) {
        return this.setDeleted(id, true);
    };

    /// Undelete one user by ID
    static async undel(id) {
        return this.setDeleted(id, false);
    };

    /// Change value of deleted flag
    static async setDeleted(id, val) {

    // Check validity of input parameters
        this.checkID(id);

    // Mark as deleted/undeleted
        const sql = `UPDATE ${Q(this.table)} SET ` +'`deleted`=' + (val ? '1' : '0') + this.sqlWhere(this.andID(id)) +
            ' LIMIT 1' // condom for delete
        ;

    // Wait mark deleted/undeleted
        await $exe(sql);
        return true;
    };

    /// Some magic patch user row
    static patchRow(row) {
        if (undefined !== row['passport_status']) this.patchPassportIDs(row);
        if (undefined !== row['address_status']) this.patchAddressIDs(row);
        if (super.patchRow) super.patchRow(row);
        return row;
    };

    /// Some magic patch user rows
    static patchRows(rows) {
        if (!rows.length) return rows;
        const firstrow = rows[0];
        if (undefined !== firstrow['passport_status']) {
            rows.forEach((row) => this.patchPassportIDs(row));
        }
        if (undefined !== firstrow['address_status']) {
            rows.forEach((row) => this.patchAddressIDs(row));
        }
        if (super.patchRows) super.patchRows(rows);
        return rows;
    };

    /// Patch passport identity_id and verification_id for return
    static patchPassportIDs(row) {
    // Patch IDs
        const patched = this.patchIDs(row['passport_status'], row['passport_identity_id'], row['passport_verification_id'], row);

    // Fill patched to row
        row['passport_status'] = patched[0];
        row['passport_identity_id'] = patched[1];
        row['passport_verification_id'] = patched[2];
    };

    /// Patch address identity_id and verification_id for return
    static patchAddressIDs(row) {
    // Patch IDs
        const patched = this.patchIDs(row['address_status'], row['address_identity_id'], row['address_verification_id'], row);

    // Fill patched to row
        row['address_status'] = patched[0];
        row['address_identity_id'] = patched[1];
        row['address_verification_id'] = patched[2];
    };

    /// Patch identity_id and verification_id for return
    static patchIDs(status, identity_id, verification_id, row) {

    // Workaround invalid verification_id
        if ('0' === verification_id) verification_id = '';

    // If absent verification, this some logic fuckups, move identity to verification and use verification+2 for identity
        if ((identity_id) && (!verification_id)) {
            verification_id = identity_id;
            identity_id = '';
        }

    // If absent identity, use verification+2 for it
        if ((!identity_id) && (verification_id) && (String(verification_id).length > 8)) identity_id = (BigInt('0x' + verification_id) - 2n).toString(16);

        if ((parseInt(row['blocked'] ?? '0')) || (parseInt(row['softblocked'] ?? '0'))) status = this.STATUS.REJECTED;
        else if (!status) status = this.STATUS.NOT_YET_SUBMITTED;
        return [status, identity_id, verification_id];
    };


    static cteLoans() {
        const ands = [];
        if (LoanBase.patchAnds) LoanBase.patchAnds(ands);
        return `${Q(this.LOANS.CTE)} AS (` +
            `SELECT ${[
                `${LoanBase.QSelect('user_id')} AS ${Q('user_id')}`,
                `MAX(${LoanBase.QSelect('created_dt')}) AS ${Q(this.LOANS.LATEST_DT)}`,
                `(SUM(IF(${LoanBase.QSelect('outstanding')}>0,1,0))>0) AS ${Q(this.LOANS.HAVE_OUTSTANDING)}`,
                `SUM(IF(${LoanBase.QSelect('outstanding')}>0,1,0)) AS ${Q(this.LOANS.COUNT_OUTSTANDING)}`,
                `(SUM(IF(${LoanBase.QSelect('outstanding')}<=0,1,0))>0) AS ${Q(this.LOANS.HAVE_COMPLETED)}`,
                `SUM(IF(${LoanBase.QSelect('outstanding')}<=0,1,0)) AS ${Q(this.LOANS.COUNT_COMPLETED)}`,
                `CONCAT(' ',GROUP_CONCAT(${LoanBase.QSelect(LoanBase.SID)},' '),' ') AS ${Q(this.LOANS.ORDER_IDS)}`,
                `CONCAT(' ',GROUP_CONCAT(${LoanBase.QSelect('pc_reference')},' '),' ') AS ${Q(this.LOANS.PC_REFERENCES)}`,
                `CONCAT(' ',GROUP_CONCAT(${LoanBase.QSelect('pp_reference')},' '),' ') AS ${Q(this.LOANS.PP_REFERENCES)}`,
            ].join(',')} ` +
            `FROM ${Q(LoanBase.table)} ` +
            (ands.length ? ` WHERE (${ands.join(')AND(')})` : '') +
            `GROUP BY ${Q('user_id')}` +
        `)`;
    };

    static joinLoans() {
        return `LEFT JOIN ${Q(this.LOANS.CTE)} ` +
            `ON ${this.QSelect(this.ID)}=${Q(this.LOANS.CTE)}.${Q('user_id')}`;
    };
}

module.exports = { User };
