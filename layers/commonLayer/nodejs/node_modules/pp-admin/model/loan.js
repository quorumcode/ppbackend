const { round } = require('mathjs');
const { Q, q } = require('pp-mysql/client').shorthands();
const { isNumber, isString } = require('./model');
const { LoanBase } = require('./loanbase');
const { LoanTrxBase } = require('./loantrxbase');
const { LoanTrx } = require('./loantrx');
const { MerchantBase } = require('./merchantbase');
const { PaymethBase } = require('./paymethbase');

/// User loan
class Loan extends LoanBase {
    static cteMerchant() {
        const ands = [];
        if (MerchantBase.patchAnds) MerchantBase.patchAnds(ands);
        return `${Q(this.MERCHANT.CTE)} AS (` +
            `SELECT ${[
                `${MerchantBase.QSelect(MerchantBase.SID)} AS ${Q(this.MERCHANT.SID)}`,
                `${MerchantBase.QSelect('name')} AS ${Q(this.MERCHANT.NAME)}`,
                `${MerchantBase.QSelect('link')} AS ${Q(this.MERCHANT.LINK)}`,
            ].join(',')} ` +
            `FROM ${Q(MerchantBase.table)} ` +
            (ands.length ? ` WHERE (${ands.join(')AND(')})` : '') +
        `)`;
    };

    static joinMerchant() {
        return `LEFT JOIN ${Q(this.MERCHANT.CTE)} ` +
            `ON ${this.QSelect(this.MERCHANT.SID)}=${Q(this.MERCHANT.CTE)}.${Q(this.MERCHANT.SID)}`;
    };

    static ctePaymeth() {
        const ands = [];
        if (PaymethBase.patchAnds) PaymethBase.patchAnds(ands);
        return `${Q(this.PAYMETH.CTE)} AS (` +
            `SELECT ${[
                `${PaymethBase.QSelect('user_id')} AS ${Q(this.PAYMETH.USER_ID)}`,
                `${PaymethBase.QSelect(PaymethBase.SID)} AS ${Q(this.PAYMETH.SID)}`,
                `${PaymethBase.QSelect('type')} AS ${Q(this.PAYMETH.TYPE)}`,
                `${PaymethBase.QSelect('digits')} AS ${Q(this.PAYMETH.DIGITS)}`,
            ].join(',')} ` +
            `FROM ${Q(PaymethBase.table)} ` +
            (ands.length ? ` WHERE (${ands.join(')AND(')})` : '') +
        `)`;
    };

    static joinPaymeth() {
        return `LEFT JOIN ${Q(this.PAYMETH.CTE)} ` +
            `ON (${this.QSelect(this.PAYMETH.SID)}=${Q(this.PAYMETH.CTE)}.${Q(this.PAYMETH.SID)})` +
                `AND(${this.QSelect('user_id')}=${Q(this.PAYMETH.CTE)}.${Q(this.PAYMETH.USER_ID)})`;
    };

    static cteLoanTrx() {
        const ands = [];
        if (LoanTrxBase.patchAnds) LoanTrxBase.patchAnds(ands);
        return `${Q(this.LOANTRX.CTE)} AS (` +
            `SELECT ${[
                `${this.QSelect(this.ID)} AS ${Q(this.ID)}`,
                `ROW_NUMBER() OVER (PARTITION BY ${this.QSelect(this.ID)}, ${Q(LoanTrxBase.jsontable)}.${Q('status')} ` +
                    `ORDER BY ${Q(LoanTrxBase.jsontable)}.${Q('utm')} ASC) AS ${Q(this.NEXTTRX.IROW)}`,
                `ROW_NUMBER() OVER (PARTITION BY ${this.QSelect(this.ID)}, ${Q(LoanTrxBase.jsontable)}.${Q('status')} ` +
                    `ORDER BY ${Q(LoanTrxBase.jsontable)}.${Q('utm')} DESC) AS ${Q(this.LASTTRX.IROW)}`,
                `ROW_NUMBER() OVER (PARTITION BY ${this.QSelect(this.ID)} ` +
                    `ORDER BY ${Q(LoanTrxBase.jsontable)}.${Q('utm')} ASC) AS ${Q(this.FIRSTTRX.IROW)}`,
                `${Q(LoanTrxBase.jsontable)}.${Q('utm')}`,
                `${Q(LoanTrxBase.jsontable)}.${Q('amount')}`,
                `${Q(LoanTrxBase.jsontable)}.${Q('status')}`,
            ].join(',')} FROM ${Q(this.table)} ` +
                `INNER JOIN ${LoanTrxBase.jsonTable()} AS ${Q(LoanTrxBase.jsontable)} ` +
            (ands.length ? ` WHERE (${ands.join(')AND(')})` : '') +
        `)`;
    }

    static joinNextTrx() {
        return `LEFT JOIN ${Q(this.LOANTRX.CTE)} AS ${Q(this.NEXTTRX.CTE)} ` +
            `ON (${this.QSelect(this.ID)}=${Q(this.NEXTTRX.CTE)}.${Q(this.ID)})` +
                `AND(${Q(this.NEXTTRX.CTE)}.${Q('status')}=${q(LoanTrxBase.STATUS.SCHEDULED)})` +
                `AND(1=${Q(this.NEXTTRX.CTE)}.${Q(this.NEXTTRX.IROW)})`;
    };

    static joinLastTrx() {
        return `LEFT JOIN ${Q(this.LOANTRX.CTE)} AS ${Q(this.LASTTRX.CTE)} ` +
            `ON (${this.QSelect(this.ID)}=${Q(this.LASTTRX.CTE)}.${Q(this.ID)})` +
            `AND(${Q(this.LASTTRX.CTE)}.${Q('status')}=${q(LoanTrxBase.STATUS.PAID)})` +
            `AND(1=${Q(this.LASTTRX.CTE)}.${Q(this.LASTTRX.IROW)})`;
    };

    static joinFirstTrx() {
        return `LEFT JOIN ${Q(this.LOANTRX.CTE)} AS ${Q(this.FIRSTTRX.CTE)} ` +
            `ON (${this.QSelect(this.ID)}=${Q(this.FIRSTTRX.CTE)}.${Q(this.ID)})` +
            `AND(1=${Q(this.FIRSTTRX.CTE)}.${Q(this.FIRSTTRX.IROW)})`;
    };

    /// Adjust transactions
    static async adj(id, apply, period, amount, adjtrx) {

    // Null to undefined for not required fields
        if ((null === apply) || (undefined === apply)) apply = this.APPLY.DRYRUN;
        if (null === period) period = undefined;
        if (null === amount) amount = undefined;
        if (null === adjtrx) adjtrx = undefined;

    // Check validity input parameters
        this.checkID(id); this.checkApply(apply); this.checkPeriod(period); this.checkAmount(amount); this.checkAdjTrx(adjtrx);

    // Get loan
        const loan = await this.row(id, []);
        if (!loan) return undefined;// Not found
        let { created_dt, outstanding_amount, last_payment_dt } = loan;
        if (outstanding_amount <= 0) throw new Error(`Can't adjust completed loan (outstanding amount <= 0)`);

    // And current scheduled loan transactions
        const trxtbl = await this.getTrxTbl(id);
        const schtrx = trxtbl.body;
        if (!schtrx) return undefined;// Not found
        if (!schtrx.length) throw new Error(`Can't adjust completed loan (no scheduled transactions)`);

    // Just return current transactions
        if ((this.APPLY.DRYRUN === apply) && (!period) && (!amount) && (!adjtrx)) return trxtbl;

    // Change amount
        if (undefined !== amount) {
            amount = Number(amount);
            if (this.APPLY.RESCHEDULE === apply) {
                if (outstanding_amount !== amount) throw new Error(`For 'apply'=${apply} amount must be equal ${outstanding_amount}`);
            }
            else if (this.APPLY.CHANGE === apply) {
                if (amount <= 0) throw new Error(`For 'apply'=${apply} amount must be greater zero`);
            }
        }
        else amount = outstanding_amount;// Not change amount

    // Apply change dates
        if (period) {
            let last_dt = last_payment_dt ?? created_dt;// Last paid or created dt
            let last_date = this.date(last_dt);
            const day = last_date.getDate();
            const today = this.date();
            switch (period) {
                case this.PERIOD.FORTNIGHTLY:
                    schtrx.forEach((trx) => {
                        this.next2Week(last_date, today);
                        trx.dt = last_date.toISOString();
                    });
                    break;
                case this.PERIOD.MONTHLY:
                    schtrx.forEach((trx) => {
                        this.nextMonth(last_date, day, today);
                        trx.dt = last_date.toISOString();
                    });
                    break;
                case this.PERIOD.CUSTOM:
                    if (!adjtrx) throw new Error(`Absent parameter 'adjtrx' required for custom period`);
                    let isch = 0;
                    last_date = today;// Previous date
                    adjtrx.forEach((atrx) => {
                        const strx = schtrx[isch++];
                        if (atrx.sid !== strx.sid) throw new Error(`Invalid sid ${atrx.sid}`);

                    // Use date from request or from DB
                        const trx_dt = atrx.dt ?? strx.dt;
                        const trx_date = this.date(trx_dt);
                        if (trx_date <= last_date) throw new Error(`Invalid sequence of dates ${trx_date.toISOString()} <= ${last_date.toISOString()}`);
                        strx.dt = trx_date.toISOString();
                        last_date = trx_date;
                    });
                    break;
            }
            if (last_date > this.getMaxLastDate(created_dt)) throw new Error(`12 month period is exceeded`);
        }

    // May be some manual changes of amounts by adjust object
        let adj_amount = 0.0; let auto_amount = 0;
        if (adjtrx) {
            let isch = 0;
            adjtrx.forEach((atrx) => {
                const strx = schtrx[isch++];
                if (atrx.sid !== strx.sid) throw new Error(`Invalid sid ${atrx.sid}`);
                if (isNumber(atrx.amount)) {
                    strx.amount = atrx.amount;
                    adj_amount = this.round(strx.amount + atrx.amount);
                }
                else ++auto_amount;
            });

    // All scheduled transactions must be recalculate amount
        }
        else auto_amount = schtrx.length;

    // If require auto recalculate some amounts
        if (auto_amount > 0) {
            let left_amount = this.round(amount - adj_amount);
            let trx_amount = this.round(left_amount/auto_amount);
            if (adjtrx) {
                let isch = 0;
                adjtrx.forEach((atrx) => {
                    const strx = schtrx[isch++];
                    if (atrx.sid !== strx.sid) throw new Error(`Invalid sid ${atrx.sid}`);
                    if (!isNumber(atrx.amount)) {
                        [left_amount, trx_amount] = this.trxAmount(left_amount, trx_amount);
                        strx.amount = trx_amount;
                    }
                });
            }
            else {
                schtrx.forEach((trx) => {
                    [left_amount, trx_amount] = this.trxAmount(left_amount, trx_amount);
                    trx.amount = trx_amount;
                });
            }
        }

        let sum_amount = 0.0;
        schtrx.forEach((trx) => sum_amount = this.round(sum_amount + trx.amount));
        if (sum_amount !== amount) throw new Error(`Sum amount ${sum_amount} != outstanding amount ${amount}`);

    // If dry run, return patched objects without writes
        if (this.APPLY.DRYRUN === apply) return trxtbl;

    // TODO save schtrx to DB
        console.log(`Apply adjust to database not implemented yet`);

    // Return real scheduled transactions from database
        return await this.getTrxTbl(id);
    };

    /// Calculate left amount and this transaction amount
    static trxAmount(left_amount, trx_amount) {
        if (left_amount <= this.round(trx_amount + 0.01)) {
            trx_amount = left_amount;
            left_amount = 0.0;
        }
        else {
            left_amount = this.round(left_amount - trx_amount);
        }
        return [ left_amount, trx_amount ];
    }

    static async getTrxTbl(id) {
        return await LoanTrx.tbl(['sid', 'dt', 'amount'], [{ fld: 'loan_id', val: id }, { fld: 'scheduled', val: 1 }]);
    }

    /// Increment last_date by 2 week, while <= today
    static next2Week(last_date, today) {
        do {

        // Increment 2 week, always valid
            last_date.setDate(last_date.getDate() + 2 * 7);

    // Scheduled must be in future only
        } while (last_date < today);
    }

    /// Increment last_date by month with try safe day of month, while <= today
    static nextMonth(last_date, day, today) {
        do {
        // Must value for getMonth after increment month
            const must_month = (last_date.getMonth() + 1) % 12;

        // Increment month, may be with overdraft
            last_date.setMonth(last_date.getMonth() + 1, day);

        // Search last day of must month by day by day decrement
            while (must_month !== last_date.getMonth()) last_date.setDate(last_date.getDate() - 1);

    // Scheduled must be in future only
        } while (last_date < today);
    }

    /// Get maximum date for last payment by loan
    static getMaxLastDate(created_dt) {

    // Loan created date
        const max_last_date = this.date(created_dt);

    // Month number must be saved (workaround 29 February)
        const must_month = max_last_date.getMonth();

    // Increment year
        max_last_date.setFullYear(max_last_date.getFullYear() + 1);

    // Search last day of must month by day by day decrement (workaround 29 February)
        while (must_month !== max_last_date.getMonth()) max_last_date.setDate(max_last_date.getDate() - 1);

        return max_last_date;
    }

    /// Creare Date() object from datetime string and set it to 00:00:00.000
    static date(dt) {
        const date = dt ? new Date(dt) : new Date();
        date.setHours(0, 0, 0, 0);
        return date;
    }

    static checkApply(apply) {
        if (!isNumber(apply)) throw new Error(`Parameter 'apply' must be integer`);
        const { DRYRUN, RESCHEDULE, CHANGE, FORCE } = this.APPLY;
        if (![ DRYRUN, RESCHEDULE, CHANGE, FORCE ].includes(apply)) throw new Error(`Unknown 'apply' ${apply}`);
    }

    static checkPeriod(period) {
        if (undefined === period) return;
        if (!isString(period)) throw new Error(`Parameter 'period' must be string`);
        const { FORTNIGHTLY, MONTHLY, CUSTOM } = this.PERIOD;
        if (![FORTNIGHTLY, MONTHLY, CUSTOM].includes(period)) throw new Error(`Unknown 'period' ${period}`);
    }

    static checkAmount(amount) {
        if (undefined === amount) return;
        if (!isNumber(amount)) throw new Error(`Parameter 'outstanding_amount' must be number`);
        if (Number(amount) !== this.round(amount)) throw new Error(`Parameter 'outstanding_amount' must be 2 digits precision`);
    }

    static checkAdjTrx(adjtrx) {
        if (undefined === adjtrx) return;
        if (!isArray(adjtrx)) throw new Error("Parameter 'adjtrx' must be array");
        adjtrx.forEach((adjtrx) => {
            const { sid, dt, amount } = adjtrx;
            if (!isString(sid)) throw new Error("Parameter 'sid' must be string");
            if (!isString(dt)) throw new Error("Parameter 'dt' must be string");
            if (!isNumber(amount)) throw new Error("Parameter 'amount' must be number");
        });
    }

    /// Round by 2 signs after point
    static round(v) {
        return round(Number(v), 2);
    }
}

module.exports = { Loan };
