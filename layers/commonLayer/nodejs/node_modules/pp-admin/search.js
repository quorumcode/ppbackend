const { q } = require('pp-mysql/client').shorthands();
const { FUNC, SEARCH, FIELD, Model } = require('./model/model');
const { User } = require('./model/user');
const { Loan } = require('./model/loan');
const { LoanTrx } = require('./model/loantrx');
const { LoanItem } = require('./model/loanitem');
const { LoanCItem } = require('./model/loancitem');
const { Merchant } = require('./model/merchant');
const { Product } = require('./model/product');

const WEIGHT = 'W';

class Search {
    static async exec(text, models) {

    // Check validity of input parameters
        text = this.checkText(text); this.checkModels(models);

    // Result of search
        const r = {
            text,
            models: {},
        }

    // Cut text to words
        const words = text.split(' ');

    // Apply search to all models in parallel
        const promises = Object.keys(models).map(async (model) => {
            r.models[model] = await this.execModel(words, models, model);
        });

    // Wait all and return
        await Promise.all(promises);
        return r;
    }

    /// Execute search by one model
    static async execModel(words, models, model) {
        const M = this.model2Model(model);
        const {get, ofs = 0, len = M.MAXLEN, search } = models[model];

    // Sum of weight for row
        const sum = [];

    // By all API fields for search
        Object.keys(search).forEach((field) => {

        // Escaped name of field
            const Qfield = M.QSelect(field);

        //Flag of concat many string by spaces with begin and and space
            const concat = search[field][SEARCH.CONCAT];

        // By all words for search
            words.forEach((word) => {

            // Weight by default is 0
                let w = '0';

            // Apply compare from soft to strong
                let W = search[field][SEARCH.WIHAS];
                if (W) w = `IF(LOCATE(${q(word.toLowerCase())},LOWER(${Qfield}))>0,${W},${w})`;

                W = search[field][SEARCH.WHAS];
                if (W) w = `IF(LOCATE(${q(word)},${Qfield})>0,${W},${w})`;

                W = search[field][SEARCH.WIEQ];
                if (W) {
                    if (concat) w = `IF(LOCATE(${q(' ' + word.toLowerCase() + ' ')},LOWER(${Qfield}))>0,${W},${w})`;
                    else w = `IF(${q(word.toLowerCase())}=LOWER(${Qfield}),${W},${w})`;
                }

                W = search[field][SEARCH.WEQ];
                if (W) {
                    if (concat) w = `IF(LOCATE(${q(' ' + word + ' ')},${Qfield})>0,${W},${w})`;
                    else w = `IF(${q(word)}=${Qfield},${W},${w})`;
                }

            // Add weight of compares to sum
                sum.push(w);
            });
        });

    // Add calculated weight to model fields
        M.api2db[WEIGHT] = {
            [FIELD.MODE]: FIELD.MODE_CALC,
            [FIELD.REQ]: Object.keys(search),
            [FIELD.SELECT]: `(${sum.join('+')})`,
        }

    // Add weight to returned fields
        get.push(WEIGHT);

    // And use weight for order
        return M.tbl(get, [ { fld: WEIGHT, func: FUNC.GT, val: 0 } ], [ [WEIGHT, 'DESC'] ], ofs, len);
    }

    /// Check text validity
    static checkText(text) {

    // Check type of text
        Model.checkTypeStringable(typeof text, "for search text");

    // Convert to string, replace not text symbols by spaces and trim result
        text = String(text).replace(/[^-a-zA-Z0-9@+.']+/g, ' ').trim();

    // Replace multi space signs by one space
        text = text.replace(/[\xA0\s\n\t]+/g, ' ');

        if ("" === text) throw new Error("Text can't be empty");
        return text;
    }

    /// Check models validity
    static checkModels(models) {
        Model.checkTypeOfV(typeof models, ["object"], "for models");
        Object.keys(models).forEach((model) => {
            Model.checkTypeOfV(typeof models[model], ["object"], `model '${model}' in models`);
            const M = this.model2Model(model);
            if (!Object.keys(M.search ?? []).length) throw new Error(`No search in ${model}`);

            const { get, ofs = 0, len = M.MAXLEN, search = Object.keys(M.search) } = models[model];

        // Check model input parameters
            M.checkGet(get); M.checkOfs(ofs); M.checkLen(len);

        // Overwrite by default, if absent
            models[model].ofs = ofs;
            models[model].len = len;
            models[model].search = this.checkSearch(M, search);
        });
    }

    static checkSearch(M, search) {

    // Check type of get
        if (!Array.isArray(search)) throw new Error("Parameter 'search' must be array");

    // Check all fields for existing
        const { api2db, search: Msearch = {} } = M;
        const r = {};
        search.forEach((apifield) => {

        // Check existing field
            if (!api2db[apifield]) throw new Error(`Unknown field '${apifield}' in parameter 'search'`);

        // Check options for search
            if (!Msearch[apifield]) throw new Error(`Unknown field for search '${apifield}' in parameter 'search'`);

        // Copy valid search field options to result
            r[apifield] = Msearch[apifield];
        });

        return r;
    }

    /// Get model object by text name of it
    static model2Model(model) {
        switch (model) {
            case 'user': return User;
            case 'loan': return Loan;
            case 'loantrx': return LoanTrx;
            case 'loanitem': return LoanItem;
            case 'loancitem': return LoanCItem;
            case 'merchant': return Merchant;
            case 'product': return Product;
            default:
                throw new Error(`Unknown model '${model}' in models`);
        }
    }
}

module.exports = { Search };
