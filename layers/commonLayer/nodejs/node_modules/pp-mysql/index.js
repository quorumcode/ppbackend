/**
* Copyright (c) 2022 Alex Offshore <offshore@aopdg.com> for Quorum IO
* Some nifty offshore patchwork and extension required for `mysql` module.
* See comments.
*/

const mysql = require('mysql');
const mysql_ServerStatus = require('mysql/lib/protocol/constants/server_status.js');

/*
* DO NOT use transactions in async code WITHOUT global connection pooling if you DO NOT KNOW what you are doing!
* Every function that uses SQL should either acquire a separate isolated connection for itself or be aware of
* the fact that connection it just used for querying SQL was in transaction state, so "succsessful result"
* does not mean "committed result". Be very careful with that.
* Maybe it's worth checking that $trx_conn is called for pooled connection (to restrict dumb $trx usage).
*/

/*
async function sample_code_trx() {
    console.log({
        ra: await $exe("SELECT @@in_transaction"),
    });
    await mysql_client.$trx({}, async (conn, ctx) => {
        console.log({
            rb: await $exe("SELECT @@in_transaction"),
            rc: await conn.$exe("SELECT @@in_transaction"),
        });
        await conn.$trx({ nest: true }, async (conn, ctx) => {
            console.log({
                rd: await $exe("SELECT @@in_transaction"),
                re: await conn.$exe("SELECT @@in_transaction"),
            });
        });
    });

    return;
}
*/

/**
* Transaction wrapper for an async function body(conn, ctx = { savepoint, ... }).
* body is called with this === conn
* opts.nest:
*   null/undefined: (default behavior) explicitly fail if it's not a top-level trx for this connection (i.e. fail if already is in transaction)
*   false: reserved, do not use
*   true: if not in transaction already, start a brand new top-level trx, otherwise create a savepoint,
*       do things and instead of { commit / rollback } do a { release savepoint / rollback to savepoint }
*/
async function $trx_conn(opts, body) {
    let conn = this;
    if (!body && typeof opts === 'function') [body, opts] = [opts, {}];

    // check if connection is already inside a transaction;
    // if it is so, create savepoint, otherwise initialize transaction
    const beg_rr = (true === opts.nest)
        ? await conn.$exe(`
            IF @@in_transaction THEN BEGIN
                EXECUTE IMMEDIATE CONCAT('SAVEPOINT ', @savepoint := CONCAT('sp', UUID_SHORT()));
                SELECT @savepoint as savepoint;
            END;
            ELSE BEGIN
                START TRANSACTION;
                SELECT NULL as savepoint;
            END; END IF
        `)
        : await conn.$exe(`
            IF @@in_transaction THEN BEGIN
                SIGNAL SQLSTATE '25000' SET MYSQL_ERRNO = 1179, MESSAGE_TEXT = 'Transaction body is not marked capable of sub-transactions';
                SELECT NULL as savepoint; /* only for resultset to be consistent */
            END;
            ELSE BEGIN
                START TRANSACTION WITH CONSISTENT SNAPSHOT;
                SELECT NULL as savepoint;
            END; END IF
        `)
    ;

    // console.log(beg_rr);
    // sp is a savepoint name allocated inside sql statement, r is a overall operation result (expected to be OkPacket)
    let [[ [{ savepoint }], beg_r ]] = beg_rr;

    // just for debugging
    // const in_transaction = beg_r.serverStatus & mysql_ServerStatus.SERVER_STATUS_IN_TRANS;
    // if (!in_transaction) {
    //     throw new Error("Server status is expected to be 'IN TRANSACTION', but it is not so.");
    // }

    try {
        const r = await body.call(conn, conn, { savepoint });
        if (savepoint) {
            // we are in "sub" transaction, so just release a savepoint and continue still being inside a transaction
            await conn.$exe(`RELEASE SAVEPOINT ${conn.escapeId(savepoint)}`);
        }
        else {
            // we are in a top-level transaction and things are done: commit everything
            await conn.$exe(`COMMIT`);
        }
        return r;
    }
    catch (err) {
        // console.error({ err });
        if (savepoint) {
            // "sub" transaction error: rollback to a savepoint
            await conn.$exe(`ROLLBACK TO SAVEPOINT ${conn.escapeId(savepoint)}`);
        }
        else {
            // top-level transaction error: rollback everything
            await conn.$exe(`ROLLBACK`);
        }
        // ...and rethrow anyway
        throw err;
    }
};

// when connection pooling is active, a connection should be "reserved" for the whole transaction
// a $trx called on a Pool objects always acquires a non-busy connection (or wait if none available)
// and therefore always leads to a top-level transaction being initiated
async function $trx_pool(opts, body) {
    // if (!body && typeof opts === 'function') [body, opts] = [opts, {}]; // not needed here, see $trx_conn

    const pool = this;
    const conn = await pool.getConnection_promise();
    try {
        // await needed, because conn.release() should be called after promise of $trx_conn is fulfilled:
        return await $trx_conn.call(conn, opts, body);
    }
    finally {
        conn.release();
    }
}

function query_promise(sql, values) {
    return new Promise((resolve, reject) => {
        this.query(sql, values, (err, results, fields) => void (err ? reject(err) : resolve([results, fields])));
    });
};

const like_regex = /[%_\\]/g;
const like_map = { "%": "\\%", "_": "\\_", "\\": "\\\\" };
const like_mapfn = (m) => like_map[m];
function shorthands() {
    return {
        Q: (identifier) => this.escapeId(identifier),
        q: (value) => this.escape(value),
        qlike: (pattern) => String(pattern).replace(like_regex, like_mapfn),

        $exe: (sql, values) => query_promise.call(this, sql, values),                                                       // alias for query_promise()
        $tbl: async (sql, values) => (await query_promise.call(this, sql, values))[0],                                      // alias for query_promise().result
        $row: async (sql, values) => (await query_promise.call(this, sql, values))[0][0],                                   // result: first row only
        $col: async (sql, values) => (await query_promise.call(this, sql, values))[0].map((row) => Object.values(row)[0]),  // result: first col only
        $one: async (sql, values) => Object.values((await query_promise.call(this, sql, values))[0][0] || {})[0],           // result: first col of first row
    };
};

const $fns = {
    Q: function(identifier) { return this.escapeId(identifier); },
    q: function (value) { return this.escape(value); },
    qlike: (pattern) => String(pattern).replace(like_regex, like_mapfn),

    $exe: query_promise,
    $tbl: async function(sql, values) { return (await this.$exe(sql, values))[0]; },                                        // alias for query_promise().result
    $row: async function(sql, values) { return (await this.$exe(sql, values))[0][0]; },                                     // result: first row only
    $col: async function(sql, values) { return (await this.$exe(sql, values))[0].map((row) => Object.values(row)[0]); },    // result: first col only
    $one: async function(sql, values) { return Object.values((await this.$exe(sql, values))[0][0] || {})[0]; },             // result: first col of first row
};

// mysql.Connection patchwork
Object.assign(require('mysql/lib/Connection').prototype, {
    query_promise,
    ...$fns,
    shorthands,
    $trx: $trx_conn,
});

// mysql.Pool patchwork
Object.assign(require('mysql/lib/Pool').prototype, {
    getConnection_promise() {
        return new Promise((resolve, reject) => {
            this.getConnection((err, conn) => void (err ? reject(err) : resolve(conn)));
        });
    },

    query_promise,
    ...$fns,
    shorthands,
    $trx: $trx_pool,
});

// mysql.createSmartPool: enable graceful connection termination once event loop becomes empty:
// conn._socket.unref() allows beforeExit to trigger once all connections are released
// and do a proper cleanup
mysql.createSmartPool = function createSmartPool(config) {
    const pool = mysql.createPool(...arguments);
    let conn_create = (conn) => {
        // console.log({ "connection created": conn.threadId });
        conn._socket.unref();
    };
    let conn_acquire = (conn) => {
        // console.log({ "connection acquired": conn.threadId });
        conn._socket.ref();
    };
    let conn_release = (conn) => {
        // console.log({ "connection released": conn.threadId });
        conn._socket.unref();
    };
    let beforeExit = (code) => {
        // console.log('Process beforeExit event with code: ', code);
        pool.off("connection", conn_create);
        pool.off("acquire", conn_acquire);
        pool.off("release", conn_release);
        process.off("beforeExit", beforeExit);
        if (pool._closed || !pool._allConnections.length) return;
        // .ref() them again: there might be some final traffic to be handled
        for (const conn of pool._allConnections) conn._socket.ref();
        pool.end((err) => void (err && console.error(err)));
    };
    pool.on("connection", conn_create);
    pool.on("acquire", conn_acquire);
    pool.on("release", conn_release);
    process.on("beforeExit", beforeExit);
    return pool;
};

module.exports = mysql;
