const AWS = require('aws-sdk');
const dynamo = new AWS.DynamoDB.DocumentClient(require('./cfg.js'));

const MERCHANT_TABLE = process.env.merchantTable

class MerchantClient {
  constructor (merchantID) {
    Object.assign(this, { merchant: merchantID })
  }

  async scan (table = MERCHANT_TABLE) {
    const scan = await dynamo.scan({
      TableName: table
    }).promise()
    return scan
  }

  async query (record = 'details') {
    const { merchant } = this
    let queryWithMeta = await dynamo.query({
      TableName: MERCHANT_TABLE,
      KeyConditionExpression: '#user = :user and begins_with (#rec, :rec)',
      ExpressionAttributeValues: {
        ':user': merchant,
        ':rec': record
      },
      ExpressionAttributeNames: {
        '#user': 'merchant',
        '#rec': 'record'
      },
      ScanIndexForward: false
    }).promise()
    return queryWithMeta
  }

  async exists (record = 'details') {
    const { Count } = await this.query(record)
    return !!(Count)
  }

  async getProductGroups () {
    const query = await this.query('productGroup')
    return query
  }

  // query product- not to double count productGroups
  async getProducts () {
    const query = await this.query('product-')
    return query
  }

  async getUser () {
    const { Items } = await this.query('user')
    return Items[0]
  }

  static async getCategory (category = 0) {
    const query = await dynamo.query({
      TableName: MERCHANT_TABLE,
      IndexName: 'category',
      KeyConditionExpression: '#category = :category',
      ExpressionAttributeValues: {
        ':category': category
      },
      ExpressionAttributeNames: {
        '#category': 'category'
      }
    }).promise()
    if (query.Count > 0) {
      return query.Items
    } else {
      return []
    }
  }

  async updateField (record, field, val) {
    const { merchant } = this
    await dynamo.update({
      TableName: MERCHANT_TABLE,
      Key: {
        merchant,
        record
      },
      UpdateExpression: 'SET #field = :val',
      ExpressionAttributeNames: {
        '#field': field
      },
      ExpressionAttributeValues: {
        ':val': val
      }
    }).promise()
  }

  async updateMultipleFields (record, payload) {
    for (const field of Object.keys(payload)) {
      const val = payload[field]
      await this.updateField(record, field, val)
    }
  }

  async putRecord (record, payload) {
    const { merchant } = this
    await dynamo.put({
      TableName: MERCHANT_TABLE,
      Item: {
        merchant,
        record,
        ...payload
      }
    }).promise()
  }

  async remove (record) {
    const { merchant } = this
    await dynamo.delete({
      TableName: MERCHANT_TABLE,
      Key: {
        merchant,
        record
      }
    }).promise()
  }
}
exports.MerchantClient = MerchantClient
