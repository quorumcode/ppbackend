const AWS = require('aws-sdk');
const dynamo = new AWS.DynamoDB.DocumentClient(require('./cfg.js'));

const TABLE = process.env.userTable

exports.handleSecondary = async (submittedNumber) => await UserClient.handleSecondary(submittedNumber);

class UserClient {
  constructor (userName) {
    Object.assign(this, { userName })
  }

  static async scan () {
    const scan = await dynamo.scan({
      TableName: TABLE
    }).promise()
    return scan
  }

  static async fromLerexID (lerexID) {
    let user = await dynamo.query({
      TableName: TABLE,
      IndexName: 'lerexID',
      KeyConditionExpression: 'lerexID = :hkey',
      ExpressionAttributeValues: {
        ':hkey': lerexID
      }
    }).promise()
    const { user: userName } = user.Items[0]
    return {
      userTable: new UserClient(userName),
      userName
    }
  }

  static async handleSecondary (submittedNumber) {
    let user = await dynamo.query({
      TableName: TABLE,
      IndexName: 'recovery',
      KeyConditionExpression: 'recoveryNumber = :hkey',
      ExpressionAttributeValues: {
        ':hkey': Number(submittedNumber)
      }
    }).promise()
    if (user.Count > 0) {
      user = user.Items[0]
      var { user: userName, recoveryStatus: numberConfirmed } = user
    } else {
      userName = submittedNumber
      numberConfirmed = true
    }
    return { userName, numberConfirmed }
  }

  static async emailConfirmed (email) {
    let status = await dynamo.query({
      TableName: TABLE,
      IndexName: 'email',
      KeyConditionExpression: '#email = :hkey',
      ExpressionAttributeNames: {
        '#email': 'email'
      },
      ExpressionAttributeValues: {
        ':hkey': email
      }
    }).promise()
    if (status.Count) {
      for (const record of status.Items) {
        if (record.emailConfirmed) {
          return true
        }
      }
    }
    return false
  }

  async fetch (record) {
    const { userName } = this
    let userItem = await dynamo.get({
      TableName: TABLE,
      Key: {
        user: Number(userName),
        record
      }
    }).promise()
    userItem = userItem.Item
    return userItem
  }

  async queryStrict (record = 'paymentMethod') {
    const { userName } = this
    let queryWithMeta = await dynamo.query({
      TableName: TABLE,
      KeyConditionExpression: '#user = :user and #rec = :rec',
      ExpressionAttributeValues: {
        ':user': Number(userName),
        ':rec': record
      },
      ExpressionAttributeNames: {
        '#user': 'user',
        '#rec': 'record'
      },
      ScanIndexForward: false
    }).promise()
    return queryWithMeta
  }

  async query (record = 'details') {
    const { userName } = this
    let queryWithMeta = await dynamo.query({
      TableName: TABLE,
      KeyConditionExpression: '#user = :user and begins_with (#rec, :rec)',
      ExpressionAttributeValues: {
        ':user': Number(userName),
        ':rec': record
      },
      ExpressionAttributeNames: {
        '#user': 'user',
        '#rec': 'record'
      },
      ScanIndexForward: false
    }).promise()
    return queryWithMeta
  }

  async deleteRecord (record) {
    const { userName } = this
    await dynamo.delete({
      TableName: TABLE,
      Key: {
        user: Number(userName),
        record
      }
    }).promise()
  }

  async exists (record = 'details') {
    const { Count } = await this.queryStrict(record)
    return !!(Count)
  }

  async details () {
    const details = await this.queryStrict('details')
    return details.Items[0]
  }

  async settings () {
    const settings = await this.queryStrict('settings')
    return settings.Items[0]
  }

  async primary () {
    const primary = await this.queryStrict('primary')
    return primary.Items[0]
  }

  async recovery () {
    const recovery = await this.queryStrict('recovery')
    return recovery.Items[0]
  }

  async status () {
    const status = await this.queryStrict('status')
    return status.Items[0]
  }

  async customer () {
    const customer = await this.queryStrict('customer')
    return customer.Items[0]
  }

  async apns () {
    const { Count, Items } = await this.queryStrict('apns')
    return (Count ? Items[0] : { devices: {} })
  }

  async paymentMethod () {
    const paymentMethod = await this.query('paymentMethod')
    return {
      count: paymentMethod.Count,
      items: paymentMethod.Items
    }
  }

  async wallet () {
    const wallet = await this.queryStrict('wallet')
    if (wallet.Count == 0) { return { activeCard: false }}
    return wallet.Items[0]
  }

  async updateField (record, field, val) {
    const { userName } = this
    await dynamo.update({
      TableName: TABLE,
      Key: {
        user: Number(userName),
        record
      },
      UpdateExpression: 'SET #field = :val',
      ExpressionAttributeNames: {
        '#field': field
      },
      ExpressionAttributeValues: {
        ':val': val
      }
    }).promise()
  }

  async updateMultipleFields (record, payload) {
    for (const field of Object.keys(payload)) {
      const val = payload[field]
      await this.updateField(record, field, val)
    }
  }

  async putRecord (record, payload) {
    const { userName } = this
    await dynamo.put({
      TableName: TABLE,
      Item: {
        user: Number(userName),
        record,
        ...payload
      }
    }).promise()
  }

  async deletePaymentMethodRecord (pmID) {
    await this.deleteRecord(
      `paymentMethod-${pmID}`
    )
  }
}
exports.UserClient = UserClient
