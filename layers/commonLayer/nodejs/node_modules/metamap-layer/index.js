const { stringToBase64 } = require('utils')
const { HttpClient } = require('aws-layer')
const USER = process.env.matiUser
const PASS = process.env.matiPass

class MetamapClient {
    constructor (props) {
        Object.assign(this, props)
    }

    // async builder to get the accessToken for the session
    static async builder () {
        const accessToken = await MetamapClient.requestAccessToken()
        return new MetamapClient({ accessToken })
    }

    static authHeaders = {
        Authorization: 'Basic ' + stringToBase64(`${USER}:${PASS}`),
        Accept: 'application/json',
        'Content-Type': 'application/x-www-form-urlencoded'
    }

    static async requestAccessToken () {
        const { authHeaders } = MetamapClient
        const tokenRequest = await HttpClient.request(
          'POST',
          'https://api.getmati.com/oauth',
          'grant_type=client_credentials',
          authHeaders,
          'body',
          'formData'
        )
        return tokenRequest.access_token
    }

    // converts identityID to a verificationID
    //  verificationID is identityID + 0x2 (usually)
    static iID2vID (identityID) {
      let verificationID = identityID
      if (verificationID) {
        // verificationID = identityID.slice(0, identityID.length - 3)
        // let suffix = parseInt(
        // identityID.slice(
        //     identityID.length - 3,
        //     identityID.length),
        // 16) + 2
        // suffix = suffix.toString(16)
        // while (suffix.length !== 3) { suffix = `0${suffix}` }
        // verificationID += suffix
        try {
          verificationID = (BigInt('0x' + verificationID) + 2n).toString(16).padStart(21, '0')
        } catch (err) {
          console.error(err, 'Verification ID parse error')
          verificationID = identityID
        }
      }
        return verificationID
    }

    async fetchVerificationData (verificationID) {
        const { accessToken } = this
        const data = await HttpClient.request(
          'GET',
          `https://api.getmati.com/v2/verifications/${verificationID}`,
          null,
          {
            Authorization: `Bearer ${accessToken}`
          }
        )
        Object.assign(this, { data })
        return this
      }

    // knwon issue: sometimes the client returns identiyID sometimes verificationID -- hence we check both. 
    // IDs are unique, the wrong value will return an error
    async processIdentityID (identityID) {
        await this.fetchVerificationData(identityID)
        if (this.data?.name === 'EntityNotFoundError' || !this.data?.identity?.status) {
          const verificationID = MetamapClient.iID2vID(identityID)
          await this.fetchVerificationData(verificationID)
          if (this.data?.name === 'EntityNotFoundError') {
            throw new Error('Couldn\'t find your verification IDs. Please, try again! Feel free to contact support in case of further hurdles.')
          }
          Object.assign(this, { verificationID: this.data.id })
        } else { this.verificationID = this.data.id }
        return this
    }

    extractNameData () {
        const { data } = this
        const nameData = {
            givenName: null,
            middleName: null,
            surname: null,
            dob: null
          }
          try {
            if (data.documents != null && data.documents.length > 0 && data.documents[0].fields != null) {
              if (data.documents[0].fields.fullName != null && data.documents[0].fields.fullName.value != null) {
                let fullName = data.documents[0].fields.fullName.value.split(' ')
                if (fullName[0] === 'MR' || 'MISS' || 'MSR') { fullName = fullName.slice(1) }
                nameData.surname = fullName[0]
                nameData.givenName = fullName[1]
                if (fullName.length > 2) {
                  fullName.splice(0, 2)
                  nameData.middleName = fullName.join(' ')
                }
                if (data.documents[0].fields.firstName != null) {
                  let firstName = data.documents[0].fields.firstName.value
                  if (firstName.indexOf(' ') > -1) {
                    firstName = firstName.split(' ')
                    if (firstName[0] === 'MR' || 'MISS' || 'MSR') { firstName = firstName.slice(1) }
                    [nameData.givenName, nameData.middleName] = [firstName[0], firstName.slice(1).join(' ')]
                  } else {
                    nameData.givenName = firstName
                  }
                }
                if (data.documents[0].fields.surname != null) {
                  nameData.surname = data.documents[0].fields.surname.value
                }
                if (data.documents[0].fields.dateOfBirth != null) {
                  nameData.dob = String(data.documents[0].fields.dateOfBirth.value)
                }
              }
            }
          } finally {
            this.nameData = nameData
            return this
          }

    }

    // returns a link not an image blob
    extractImageData () {
        const { data } = this
        this.imageData = data ? data.documents[0].photos[0] : ''
        return this
    }

    extractStatus () {
        const { data } = this
        this.status = data.identity?.status ?? 'rejected'
        return this
    }
}

module.exports = { MetamapClient }